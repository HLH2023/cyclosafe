# æ¨¡å‹éƒ¨ç½²æŒ‡å—

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜å¦‚ä½•å°†è®­ç»ƒå¥½çš„æœºå™¨å­¦ä¹ æ¨¡å‹éƒ¨ç½²åˆ°å¾®ä¿¡å°ç¨‹åºä¸­ã€‚

---

## ç›®å½•

1. [éƒ¨ç½²æ¦‚è¿°](#1-éƒ¨ç½²æ¦‚è¿°)
2. [æ¨¡å‹è½¬æ¢](#2-æ¨¡å‹è½¬æ¢)
3. [å°ç¨‹åºé›†æˆ](#3-å°ç¨‹åºé›†æˆ)
4. [æ¨ç†å®ç°](#4-æ¨ç†å®ç°)
5. [æ€§èƒ½ä¼˜åŒ–](#5-æ€§èƒ½ä¼˜åŒ–)
6. [ç‰ˆæœ¬ç®¡ç†](#6-ç‰ˆæœ¬ç®¡ç†)
7. [æ›´æ–°ç­–ç•¥](#7-æ›´æ–°ç­–ç•¥)

---

## 1. éƒ¨ç½²æ¦‚è¿°

### 1.1 éƒ¨ç½²æ¶æ„

```
è®­ç»ƒå®Œæˆçš„æ¨¡å‹ (sklearn .pkl)
    â†“
è½¬æ¢ä¸º TensorFlow/Keras æ ¼å¼
    â†“
è½¬æ¢ä¸º TensorFlow.js æ ¼å¼
    â†“
ä¸Šä¼ åˆ°äº‘å­˜å‚¨/CDN
    â†“
å°ç¨‹åºä¸‹è½½å¹¶åŠ è½½æ¨¡å‹
    â†“
æœ¬åœ°æ¨ç†
```

### 1.2 æŠ€æœ¯é€‰å‹

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èåº¦ |
|-----|------|------|-------|
| **æ–¹æ¡ˆA: TensorFlow.js** | å®˜æ–¹æ”¯æŒã€åŠŸèƒ½å®Œæ•´ | æ¨¡å‹å¤§ | â­â­â­â­ |
| **æ–¹æ¡ˆB: ONNX.js** | æ¨¡å‹å°ã€é€Ÿåº¦å¿« | å°ç¨‹åºæ”¯æŒæœ‰é™ | â­â­â­ |
| **æ–¹æ¡ˆC: è‡ªå®šä¹‰æ¨ç†** | æ¨¡å‹æœ€å° | åŠŸèƒ½å—é™ | â­â­â­â­â­ |

**æ¨è:** ä½¿ç”¨æ–¹æ¡ˆCï¼ˆè‡ªå®šä¹‰æ¨ç†ï¼‰ï¼Œå°†Random Forestæ¨¡å‹å‚æ•°å¯¼å‡ºä¸ºJSONï¼Œåœ¨å°ç¨‹åºä¸­å®ç°è½»é‡çº§æ¨ç†å¼•æ“ã€‚

---

## 2. æ¨¡å‹è½¬æ¢

### 2.1 å¯¼å‡ºRandom Forestå‚æ•°

ç”±äºRandom Forestæ¨¡å‹è¾ƒå¤§ï¼ˆé€šå¸¸>5MBï¼‰ï¼Œæˆ‘ä»¬é‡‡ç”¨è½»é‡çº§æ–¹æ¡ˆï¼šå¯¼å‡ºæ¨¡å‹å‚æ•°ä¸ºJSONã€‚

```python
# training/export_model.py
import joblib
import json
import numpy as np

class ModelExporter:
    """æ¨¡å‹å¯¼å‡ºå™¨"""

    def __init__(self, model_path):
        self.model = joblib.load(model_path)

    def export_to_json(self, output_path='model_params.json'):
        """å¯¼å‡ºä¸ºJSONæ ¼å¼ï¼ˆè½»é‡çº§ï¼‰"""

        if not hasattr(self.model, 'estimators_'):
            raise ValueError("æ¨¡å‹å¿…é¡»æ˜¯RandomForestClassifier")

        # æå–å…³é”®å‚æ•°
        model_params = {
            'type': 'random_forest',
            'n_estimators': self.model.n_estimators,
            'n_features': self.model.n_features_in_,
            'n_classes': self.model.n_classes_,
            'trees': []
        }

        # å¯¼å‡ºæ¯æ£µæ ‘ï¼ˆç®€åŒ–ç‰ˆï¼‰
        for tree in self.model.estimators_[:10]:  # åªå¯¼å‡ºå‰10æ£µæ ‘ï¼ˆå‡å°ä½“ç§¯ï¼‰
            tree_data = self._export_tree(tree.tree_)
            model_params['trees'].append(tree_data)

        # ä¿å­˜
        with open(output_path, 'w') as f:
            json.dump(model_params, f)

        print(f"âœ… æ¨¡å‹å·²å¯¼å‡º: {output_path}")
        return output_path

    def _export_tree(self, tree):
        """å¯¼å‡ºå•æ£µå†³ç­–æ ‘"""

        return {
            'feature': tree.feature.tolist(),
            'threshold': tree.threshold.tolist(),
            'children_left': tree.children_left.tolist(),
            'children_right': tree.children_right.tolist(),
            'value': tree.value.tolist()
        }

    def export_feature_config(self, output_path='feature_config.json'):
        """å¯¼å‡ºç‰¹å¾æå–é…ç½®"""

        config = {
            'window_size': 100,
            'overlap': 50,
            'sampling_rate': 50,
            'feature_list': [
                'mean', 'std', 'min', 'max', 'rms',
                'skewness', 'kurtosis', 'energy'
            ]
        }

        with open(output_path, 'w') as f:
            json.dump(config, f, indent=2)

        print(f"âœ… ç‰¹å¾é…ç½®å·²å¯¼å‡º: {output_path}")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    exporter = ModelExporter('models/fall_detection_rf.pkl')
    exporter.export_to_json('models/model_params.json')
    exporter.export_feature_config('models/feature_config.json')
```

### 2.2 æ–¹æ¡ˆBï¼šTensorFlow.jsè½¬æ¢ï¼ˆå¯é€‰ï¼‰

å¦‚æœä½¿ç”¨æ·±åº¦å­¦ä¹ æ¨¡å‹ï¼ˆCNN-LSTMï¼‰ï¼Œå¯ä½¿ç”¨TensorFlow.jsï¼š

```python
# training/export_tfjs.py
import tensorflow as tf
import tensorflowjs as tfjs

def export_to_tfjs(keras_model_path, output_dir):
    """è½¬æ¢Kerasæ¨¡å‹ä¸ºTensorFlow.jsæ ¼å¼"""

    # åŠ è½½Kerasæ¨¡å‹
    model = tf.keras.models.load_model(keras_model_path)

    # è½¬æ¢å¹¶ä¿å­˜
    tfjs.converters.save_keras_model(model, output_dir)

    print(f"âœ… TensorFlow.jsæ¨¡å‹å·²ä¿å­˜: {output_dir}")

# ä½¿ç”¨
export_to_tfjs('models/fall_detection_cnn.h5', 'models/tfjs_model')
```

---

## 3. å°ç¨‹åºé›†æˆ

### 3.1 åˆ›å»ºMLæ¨¡å‹æœåŠ¡

**æ–‡ä»¶è·¯å¾„:** `/services/mlModel.js`

```javascript
/**
 * æœºå™¨å­¦ä¹ æ¨¡å‹æœåŠ¡
 * å®ç°è½»é‡çº§Random Forestæ¨ç†
 */

class MLFallDetector {
  constructor() {
    this.model = null;
    this.featureConfig = null;
    this.isLoaded = false;
  }

  /**
   * åŠ è½½æ¨¡å‹
   */
  async loadModel(modelUrl, featureConfigUrl) {
    try {
      console.log('[MLModel] å¼€å§‹åŠ è½½æ¨¡å‹...');

      // åŠ è½½æ¨¡å‹å‚æ•°
      const modelResponse = await uni.request({
        url: modelUrl,
        method: 'GET'
      });

      if (modelResponse.statusCode === 200) {
        this.model = modelResponse.data;
      } else {
        throw new Error('æ¨¡å‹åŠ è½½å¤±è´¥');
      }

      // åŠ è½½ç‰¹å¾é…ç½®
      const configResponse = await uni.request({
        url: featureConfigUrl,
        method: 'GET'
      });

      if (configResponse.statusCode === 200) {
        this.featureConfig = configResponse.data;
      } else {
        throw new Error('ç‰¹å¾é…ç½®åŠ è½½å¤±è´¥');
      }

      this.isLoaded = true;
      console.log('[MLModel] æ¨¡å‹åŠ è½½æˆåŠŸ');

    } catch (err) {
      console.error('[MLModel] æ¨¡å‹åŠ è½½å¤±è´¥', err);
      throw err;
    }
  }

  /**
   * é¢„æµ‹
   * @param {Array} windowData - çª—å£æ•°æ® [{acc: {x,y,z}, gyro: {x,y,z}}, ...]
   * @returns {number} æ‘”å€’æ¦‚ç‡ (0-1)
   */
  predict(windowData) {
    if (!this.isLoaded) {
      throw new Error('æ¨¡å‹æœªåŠ è½½');
    }

    if (windowData.length < this.featureConfig.window_size) {
      throw new Error('æ•°æ®é•¿åº¦ä¸è¶³');
    }

    // 1. æå–ç‰¹å¾
    const features = this.extractFeatures(windowData);

    // 2. Random Forestæ¨ç†
    const probability = this.randomForestPredict(features);

    return probability;
  }

  /**
   * æå–ç‰¹å¾ï¼ˆç®€åŒ–ç‰ˆï¼‰
   */
  extractFeatures(windowData) {
    const features = [];

    // æå–åŠ é€Ÿåº¦å’Œè§’é€Ÿåº¦æ•°æ®
    const accX = windowData.map(d => d.acc.x);
    const accY = windowData.map(d => d.acc.y);
    const accZ = windowData.map(d => d.acc.z);
    const gyroX = windowData.map(d => d.gyro.x);
    const gyroY = windowData.map(d => d.gyro.y);
    const gyroZ = windowData.map(d => d.gyro.z);

    const allSignals = [accX, accY, accZ, gyroX, gyroY, gyroZ];

    // å¯¹æ¯ä¸ªè½´æå–åŸºæœ¬ç»Ÿè®¡ç‰¹å¾
    allSignals.forEach(signal => {
      features.push(this.mean(signal));      // å‡å€¼
      features.push(this.std(signal));       // æ ‡å‡†å·®
      features.push(Math.min(...signal));    // æœ€å°å€¼
      features.push(Math.max(...signal));    // æœ€å¤§å€¼
      features.push(this.rms(signal));       // RMS
    });

    // åˆæˆç‰¹å¾
    const accMag = windowData.map(d =>
      Math.sqrt(d.acc.x**2 + d.acc.y**2 + d.acc.z**2)
    );
    const gyroMag = windowData.map(d =>
      Math.sqrt(d.gyro.x**2 + d.gyro.y**2 + d.gyro.z**2)
    );

    features.push(this.mean(accMag));
    features.push(Math.max(...accMag));
    features.push(this.mean(gyroMag));
    features.push(Math.max(...gyroMag));

    return features;
  }

  /**
   * Random Forestæ¨ç†
   */
  randomForestPredict(features) {
    const trees = this.model.trees;
    let votes = 0;

    // å¯¹æ¯æ£µæ ‘è¿›è¡Œé¢„æµ‹
    trees.forEach(tree => {
      const prediction = this.predictTree(tree, features);
      votes += prediction;
    });

    // è¿”å›æ¦‚ç‡ï¼ˆæŠ•ç¥¨æ¯”ä¾‹ï¼‰
    return votes / trees.length;
  }

  /**
   * å•æ£µå†³ç­–æ ‘é¢„æµ‹
   */
  predictTree(tree, features) {
    let nodeIndex = 0;

    // éå†å†³ç­–æ ‘
    while (tree.children_left[nodeIndex] !== -1) {
      const feature = tree.feature[nodeIndex];
      const threshold = tree.threshold[nodeIndex];

      if (features[feature] <= threshold) {
        nodeIndex = tree.children_left[nodeIndex];
      } else {
        nodeIndex = tree.children_right[nodeIndex];
      }
    }

    // è¿”å›å¶èŠ‚ç‚¹çš„å€¼ï¼ˆ0æˆ–1ï¼‰
    const value = tree.value[nodeIndex];
    return value[0][1] > value[0][0] ? 1 : 0;
  }

  // ========== æ•°å­¦å·¥å…·å‡½æ•° ==========

  mean(arr) {
    return arr.reduce((a, b) => a + b, 0) / arr.length;
  }

  std(arr) {
    const m = this.mean(arr);
    const variance = arr.reduce((sum, val) => sum + (val - m) ** 2, 0) / arr.length;
    return Math.sqrt(variance);
  }

  rms(arr) {
    const sumSquares = arr.reduce((sum, val) => sum + val ** 2, 0);
    return Math.sqrt(sumSquares / arr.length);
  }
}

// å¯¼å‡ºå•ä¾‹
const mlModel = new MLFallDetector();

export default mlModel;
```

### 3.2 åœ¨éª‘è¡Œé¡µé¢é›†æˆ

ä¿®æ”¹ `pages/riding/riding.vue`ï¼Œé›†æˆMLæ¨¡å‹ï¼š

```javascript
import mlModel from '@/services/mlModel.js';

// åœ¨ onLoad ä¸­åŠ è½½æ¨¡å‹
onLoad(async () => {
  try {
    await mlModel.loadModel(
      'https://your-cdn.com/models/model_params.json',
      'https://your-cdn.com/models/feature_config.json'
    );
    console.log('MLæ¨¡å‹åŠ è½½æˆåŠŸ');
  } catch (err) {
    console.error('MLæ¨¡å‹åŠ è½½å¤±è´¥', err);
    // é™çº§åˆ°é˜ˆå€¼ç®—æ³•
  }
});

// æ··åˆæ£€æµ‹ç­–ç•¥
const detectFall = (windowData) => {
  // 1. å¿«é€Ÿé˜ˆå€¼é¢„æ£€
  if (!quickThresholdCheck(windowData)) {
    return false;
  }

  // 2. MLæ¨¡å‹ç²¾ç¡®åˆ¤æ–­
  try {
    const probability = mlModel.predict(windowData);
    return probability > 0.7; // é˜ˆå€¼å¯è°ƒ
  } catch (err) {
    console.error('MLæ¨ç†å¤±è´¥ï¼Œé™çº§åˆ°é˜ˆå€¼ç®—æ³•', err);
    return thresholdBasedDetection(windowData);
  }
};
```

---

## 4. æ¨ç†å®ç°

### 4.1 å®æ—¶æ¨ç†ç®¡é“

```javascript
/**
 * å®æ—¶æ‘”å€’æ£€æµ‹æœåŠ¡
 */
class RealtimeFallDetectionService {
  constructor() {
    this.buffer = [];
    this.windowSize = 100;
    this.mlModel = mlModel;
    this.thresholdDetector = thresholdDetector;
  }

  /**
   * æ·»åŠ ä¼ æ„Ÿå™¨æ•°æ®
   */
  addSensorData(acc, gyro) {
    this.buffer.push({ acc, gyro, timestamp: Date.now() });

    // ç»´æŠ¤çª—å£å¤§å°
    if (this.buffer.length > this.windowSize) {
      this.buffer.shift();
    }

    // çª—å£æ»¡åè¿›è¡Œæ£€æµ‹
    if (this.buffer.length === this.windowSize) {
      this.detect();
    }
  }

  /**
   * æ··åˆæ£€æµ‹ç­–ç•¥
   */
  detect() {
    // ç­–ç•¥1: å¿«é€Ÿé˜ˆå€¼é¢„æ£€ï¼ˆèŠ‚çœè®¡ç®—ï¼‰
    const quickCheck = this.quickCheck();
    if (!quickCheck) {
      return false; // æ˜æ˜¾ä¸æ˜¯æ‘”å€’ï¼Œè·³è¿‡ML
    }

    // ç­–ç•¥2: MLæ¨¡å‹ç²¾ç¡®åˆ¤æ–­
    try {
      const probability = this.mlModel.predict(this.buffer);

      if (probability > 0.7) {
        this.onFallDetected('ml', probability);
        return true;
      }
    } catch (err) {
      // MLå¤±è´¥ï¼Œé™çº§åˆ°é˜ˆå€¼ç®—æ³•
      console.warn('MLæ¨ç†å¤±è´¥ï¼Œä½¿ç”¨é˜ˆå€¼ç®—æ³•', err);
      return this.thresholdDetector.detect(this.buffer);
    }

    return false;
  }

  /**
   * å¿«é€Ÿé˜ˆå€¼æ£€æŸ¥
   */
  quickCheck() {
    // è®¡ç®—æ€»åŠ é€Ÿåº¦
    const accMagnitudes = this.buffer.map(d =>
      Math.sqrt(d.acc.x**2 + d.acc.y**2 + d.acc.z**2)
    );

    const maxAcc = Math.max(...accMagnitudes);

    // å¦‚æœåŠ é€Ÿåº¦å°äºé˜ˆå€¼ï¼Œè‚¯å®šä¸æ˜¯æ‘”å€’
    return maxAcc > 12.0; // m/sÂ²
  }

  /**
   * æ‘”å€’æ£€æµ‹å›è°ƒ
   */
  onFallDetected(method, confidence) {
    console.warn(`[æ£€æµ‹åˆ°æ‘”å€’] æ–¹æ³•:${method}, ç½®ä¿¡åº¦:${confidence.toFixed(3)}`);

    // è§¦å‘è­¦å‘Š
    uni.vibrateLong();
    uni.showModal({
      title: 'âš ï¸ æ‘”å€’æ£€æµ‹',
      content: `æ£€æµ‹åˆ°æ‘”å€’ï¼ˆç½®ä¿¡åº¦: ${(confidence*100).toFixed(1)}%ï¼‰ï¼Œæ˜¯å¦éœ€è¦å¸®åŠ©ï¼Ÿ`
    });
  }
}

export default new RealtimeFallDetectionService();
```

---

## 5. æ€§èƒ½ä¼˜åŒ–

### 5.1 æ¨¡å‹å‹ç¼©

```python
# å‡å°‘æ ‘çš„æ•°é‡ï¼ˆå‡†ç¡®ç‡ä¸‹é™çº¦1-2%ï¼‰
def compress_model(model, n_trees=20):
    """å‹ç¼©Random Forestæ¨¡å‹"""

    compressed_estimators = model.estimators_[:n_trees]
    model.estimators_ = compressed_estimators
    model.n_estimators = n_trees

    return model

# ä½¿ç”¨
compressed_model = compress_model(model, n_trees=20)
```

### 5.2 ç‰¹å¾é€‰æ‹©

```python
# åªä½¿ç”¨æœ€é‡è¦çš„ç‰¹å¾
def select_top_features(X, y, n_features=30):
    """é€‰æ‹©æœ€é‡è¦çš„ç‰¹å¾"""

    from sklearn.feature_selection import SelectKBest, f_classif

    selector = SelectKBest(f_classif, k=n_features)
    X_selected = selector.fit_transform(X, y)

    return X_selected, selector
```

### 5.3 å°ç¨‹åºç«¯ä¼˜åŒ–

```javascript
// 1. ç‰¹å¾æå–ä¼˜åŒ–ï¼ˆåªè®¡ç®—å…³é”®ç‰¹å¾ï¼‰
extractFeaturesOptimized(windowData) {
  const features = [];

  // åªæå–æœ€é‡è¦çš„ç‰¹å¾ï¼ˆå‡å°‘è®¡ç®—é‡ï¼‰
  const accX = windowData.map(d => d.acc.x);
  const accMag = windowData.map(d =>
    Math.sqrt(d.acc.x**2 + d.acc.y**2 + d.acc.z**2)
  );

  features.push(
    this.mean(accMag),
    Math.max(...accMag),
    this.std(accMag)
  );

  return features;
}

// 2. æ¨ç†èŠ‚æµï¼ˆé¿å…è¿‡åº¦è®¡ç®—ï¼‰
const throttledDetect = throttle(this.detect, 500); // æœ€å¤š0.5ç§’æ£€æµ‹ä¸€æ¬¡
```

### 5.4 å»¶è¿ŸåŠ è½½

```javascript
// å»¶è¿ŸåŠ è½½æ¨¡å‹ï¼ˆä¸é˜»å¡å¯åŠ¨ï¼‰
setTimeout(async () => {
  await mlModel.loadModel(...);
}, 3000);
```

---

## 6. ç‰ˆæœ¬ç®¡ç†

### 6.1 æ¨¡å‹ç‰ˆæœ¬åŒ–

```javascript
// services/modelVersion.js
class ModelVersionManager {
  constructor() {
    this.currentVersion = null;
    this.modelCache = {};
  }

  /**
   * æ£€æŸ¥æ›´æ–°
   */
  async checkForUpdates() {
    try {
      const response = await uni.request({
        url: 'https://api.example.com/api/model/download',
        method: 'GET'
      });

      if (response.statusCode === 200) {
        const latestVersion = response.data.data.model_version;
        const currentVersion = uni.getStorageSync('model_version');

        if (latestVersion !== currentVersion) {
          return {
            hasUpdate: true,
            latestVersion,
            modelUrl: response.data.data.model_url
          };
        }
      }

      return { hasUpdate: false };
    } catch (err) {
      console.error('æ£€æŸ¥æ›´æ–°å¤±è´¥', err);
      return { hasUpdate: false };
    }
  }

  /**
   * ä¸‹è½½æ–°æ¨¡å‹
   */
  async downloadModel(modelUrl, version) {
    uni.showLoading({ title: 'æ›´æ–°æ¨¡å‹ä¸­...' });

    try {
      const response = await uni.request({
        url: modelUrl,
        method: 'GET'
      });

      if (response.statusCode === 200) {
        // ä¿å­˜åˆ°æœ¬åœ°
        uni.setStorageSync('model_data', response.data);
        uni.setStorageSync('model_version', version);

        uni.showToast({
          title: 'æ¨¡å‹æ›´æ–°æˆåŠŸ',
          icon: 'success'
        });

        return true;
      }
    } catch (err) {
      console.error('æ¨¡å‹ä¸‹è½½å¤±è´¥', err);
      uni.showToast({
        title: 'æ›´æ–°å¤±è´¥',
        icon: 'none'
      });
      return false;
    } finally {
      uni.hideLoading();
    }
  }
}

export default new ModelVersionManager();
```

### 6.2 è‡ªåŠ¨æ›´æ–°

```javascript
// åœ¨App.vueçš„onLaunchä¸­
import modelVersionManager from '@/services/modelVersion.js';

onLaunch(async () => {
  // æ£€æŸ¥æ¨¡å‹æ›´æ–°
  const updateInfo = await modelVersionManager.checkForUpdates();

  if (updateInfo.hasUpdate) {
    uni.showModal({
      title: 'æ¨¡å‹æ›´æ–°',
      content: `å‘ç°æ–°ç‰ˆæœ¬ ${updateInfo.latestVersion}ï¼Œæ˜¯å¦æ›´æ–°ï¼Ÿ`,
      success: async (res) => {
        if (res.confirm) {
          await modelVersionManager.downloadModel(
            updateInfo.modelUrl,
            updateInfo.latestVersion
          );
        }
      }
    });
  }
});
```

---

## 7. æ›´æ–°ç­–ç•¥

### 7.1 ç°åº¦å‘å¸ƒ

```javascript
// åç«¯APIè¿”å›
{
  "model_version": "v1.2.0",
  "rollout_percentage": 20,  // ç°åº¦20%ç”¨æˆ·
  "model_url": "https://cdn.example.com/models/v1.2.0/model.json"
}

// å°ç¨‹åºç«¯åˆ¤æ–­
const shouldUpdate = (rolloutPercentage) => {
  const userId = uni.getStorageSync('anonymous_user_id');
  const hash = simpleHash(userId);
  return (hash % 100) < rolloutPercentage;
};
```

### 7.2 A/Bæµ‹è¯•

```javascript
class ABTestManager {
  constructor() {
    this.variant = this.assignVariant();
  }

  assignVariant() {
    const userId = uni.getStorageSync('anonymous_user_id');
    const hash = simpleHash(userId);

    // 50% Aç»„ï¼ˆMLæ¨¡å‹ï¼‰ï¼Œ50% Bç»„ï¼ˆé˜ˆå€¼ç®—æ³•ï¼‰
    return (hash % 2 === 0) ? 'A' : 'B';
  }

  getDetector() {
    if (this.variant === 'A') {
      return mlModel;
    } else {
      return thresholdDetector;
    }
  }

  logEvent(eventType, data) {
    // ä¸ŠæŠ¥A/Bæµ‹è¯•æ•°æ®
    uni.request({
      url: 'https://api.example.com/api/ab-test/log',
      method: 'POST',
      data: {
        variant: this.variant,
        eventType,
        data,
        timestamp: Date.now()
      }
    });
  }
}
```

### 7.3 å›æ»šæœºåˆ¶

```javascript
// å¦‚æœæ–°æ¨¡å‹è¡¨ç°ä¸ä½³ï¼Œå¿«é€Ÿå›æ»š
const rollbackModel = async () => {
  const previousVersion = uni.getStorageSync('model_version_backup');

  if (previousVersion) {
    uni.setStorageSync('model_version', previousVersion);
    uni.showToast({
      title: 'å·²å›æ»šåˆ°ä¸Šä¸€ç‰ˆæœ¬',
      icon: 'success'
    });
  }
};
```

---

## 8. ç›‘æ§å’Œæ—¥å¿—

### 8.1 æ€§èƒ½ç›‘æ§

```javascript
class PerformanceMonitor {
  logInference(duration, result) {
    console.log(`[æ€§èƒ½] æ¨ç†è€—æ—¶: ${duration}ms, ç»“æœ: ${result}`);

    // ä¸ŠæŠ¥ç»Ÿè®¡
    if (duration > 100) {
      console.warn('[æ€§èƒ½è­¦å‘Š] æ¨ç†è€—æ—¶è¿‡é•¿');
    }
  }

  logAccuracy(prediction, userFeedback) {
    // ç”¨æˆ·åé¦ˆï¼šæ˜¯å¦çœŸçš„æ‘”å€’äº†
    const isCorrect = prediction === userFeedback;

    console.log(`[å‡†ç¡®æ€§] é¢„æµ‹:${prediction}, å®é™…:${userFeedback}, æ­£ç¡®:${isCorrect}`);

    // ä¸ŠæŠ¥åˆ°åç«¯
    uni.request({
      url: 'https://api.example.com/api/feedback',
      method: 'POST',
      data: {
        prediction,
        userFeedback,
        timestamp: Date.now()
      }
    });
  }
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£ä»‹ç»äº†å®Œæ•´çš„æ¨¡å‹éƒ¨ç½²æµç¨‹ï¼š

1. âœ… **æ¨¡å‹è½¬æ¢**: sklearn â†’ JSONï¼ˆè½»é‡çº§ï¼‰
2. âœ… **å°ç¨‹åºé›†æˆ**: å®ç°æ¨ç†å¼•æ“
3. âœ… **æ¨ç†å®ç°**: æ··åˆæ£€æµ‹ç­–ç•¥
4. âœ… **æ€§èƒ½ä¼˜åŒ–**: æ¨¡å‹å‹ç¼©ã€ç‰¹å¾é€‰æ‹©
5. âœ… **ç‰ˆæœ¬ç®¡ç†**: è‡ªåŠ¨æ›´æ–°ã€ç°åº¦å‘å¸ƒ
6. âœ… **æ›´æ–°ç­–ç•¥**: A/Bæµ‹è¯•ã€å›æ»šæœºåˆ¶
7. âœ… **ç›‘æ§æ—¥å¿—**: æ€§èƒ½ç›‘æ§ã€å‡†ç¡®æ€§è·Ÿè¸ª

**å…³é”®è¦ç‚¹:**
- ä½¿ç”¨è½»é‡çº§JSONæ ¼å¼éƒ¨ç½²ï¼ˆ< 500KBï¼‰
- æ··åˆæ£€æµ‹ç­–ç•¥ï¼ˆé˜ˆå€¼é¢„æ£€ + MLç²¾ç¡®åˆ¤æ–­ï¼‰
- ä¼˜é›…é™çº§ï¼ˆMLå¤±è´¥æ—¶ä½¿ç”¨é˜ˆå€¼ç®—æ³•ï¼‰
- æŒç»­ä¼˜åŒ–ï¼ˆæ”¶é›†åé¦ˆã€è¿­ä»£æ¨¡å‹ï¼‰

---

## ä¸‹ä¸€æ­¥

1. ğŸ“Š æ”¶é›†è¶³å¤Ÿçš„è®­ç»ƒæ•°æ®ï¼ˆ100+æ‘”å€’ï¼Œ1000+æ­£å¸¸ï¼‰
2. ğŸ¤– è®­ç»ƒå¹¶è¯„ä¼°æ¨¡å‹
3. ğŸ“¦ æŒ‰ç…§æœ¬æ–‡æ¡£éƒ¨ç½²æ¨¡å‹
4. ğŸ”„ æŒç»­ç›‘æ§å’Œä¼˜åŒ–

ç¥éƒ¨ç½²é¡ºåˆ©ï¼ğŸš€
