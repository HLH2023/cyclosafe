# 摔倒检测ML训练系统 - 完整实施指南

本指南提供完整的代码和步骤，用于搭建基于FastAPI的机器学习训练系统。

---

## 目录结构

```
backend/                           # Python后端
├── main.py                       # FastAPI应用入口
├── config.py                     # 配置文件
├── models.py                     # 数据库模型
├── database.py                   # 数据库连接
├── api/
│   ├── upload.py                # 数据上传API
│   ├── training.py              # 训练管理API
│   └── data.py                  # 数据查询API
├── training/
│   ├── feature_extraction.py   # 特征提取
│   ├── train_model.py           # 模型训练
│   └── export_model.py          # 模型导出
├── requirements.txt
└── .env

miniprogram/                      # 小程序前端
├── services/
│   └── dataCollector.js         # 数据收集器
├── pages/
│   ├── simulate/                # 模拟摔倒页面
│   │   ├── simulate.vue
│   │   └── simulate.js
│   └── riding/                  # 骑行页面（改进）
│       └── riding.vue
```

---

## 第一部分：后端实现

### 1. 环境准备

```bash
# 创建Python虚拟环境
python3 -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate    # Windows

# 安装依赖
pip install fastapi uvicorn sqlalchemy pymysql aiomysql pandas numpy scikit-learn joblib
```

### 2. requirements.txt

```txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
pymysql==1.1.0
aiomysql==0.2.0
pydantic==2.5.0
python-multipart==0.0.6
pandas==2.1.3
numpy==1.26.2
scikit-learn==1.3.2
joblib==1.3.2
python-dotenv==1.0.0
```

### 3. config.py - 配置文件

```python
import os
from dotenv import load_dotenv

load_dotenv()

# 数据库配置
DATABASE_URL = os.getenv(
    'DATABASE_URL',
    'mysql+pymysql://root:password@localhost:3306/fall_detection_training'
)

# API配置
ADMIN_API_KEY = os.getenv('ADMIN_API_KEY', 'your-secret-api-key')

# 文件存储
MODEL_STORAGE_PATH = os.getenv('MODEL_STORAGE_PATH', './models')
LOG_STORAGE_PATH = os.getenv('LOG_STORAGE_PATH', './logs')

# 训练配置
MAX_UPLOAD_SIZE_MB = 10
SAMPLES_PER_BATCH = 1000
```

### 4. database.py - 数据库连接

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from config import DATABASE_URL

engine = create_engine(DATABASE_URL, echo=False)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    """获取数据库会话"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### 5. models.py - 数据模型

```python
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean, Text, Enum, BigInteger, ForeignKey, JSON
from sqlalchemy.sql import func
from database import Base

class TrainingSample(Base):
    __tablename__ = 'training_samples'

    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(String(64), nullable=False)
    label = Column(Enum('fall', 'normal'), nullable=False)
    source = Column(Enum('simulate', 'riding'), nullable=False)
    duration = Column(Integer, nullable=False)
    sample_count = Column(Integer, nullable=False)
    uploaded_at = Column(DateTime, default=func.now())
    processed = Column(Boolean, default=False)
    metadata = Column(JSON, nullable=True)

class SensorData(Base):
    __tablename__ = 'sensor_data'

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    sample_id = Column(Integer, ForeignKey('training_samples.id', ondelete='CASCADE'), nullable=False)
    timestamp = Column(BigInteger, nullable=False)
    acc_x = Column(Float, nullable=False)
    acc_y = Column(Float, nullable=False)
    acc_z = Column(Float, nullable=False)
    gyro_x = Column(Float, nullable=False)
    gyro_y = Column(Float, nullable=False)
    gyro_z = Column(Float, nullable=False)

class TrainingJob(Base):
    __tablename__ = 'training_jobs'

    id = Column(Integer, primary_key=True, autoincrement=True)
    status = Column(Enum('pending', 'running', 'completed', 'failed'), default='pending')
    algorithm = Column(String(64), nullable=False)
    train_samples = Column(Integer, nullable=True)
    val_samples = Column(Integer, nullable=True)
    accuracy = Column(Float, nullable=True)
    precision_val = Column(Float, nullable=True)
    recall_val = Column(Float, nullable=True)
    f1_score = Column(Float, nullable=True)
    model_path = Column(String(255), nullable=True)
    config = Column(JSON, nullable=True)
    error_message = Column(Text, nullable=True)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=func.now())
```

### 6. main.py - FastAPI应用

```python
from fastapi import FastAPI, HTTPException, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
from sqlalchemy.orm import Session
from database import get_db, engine, Base
from models import TrainingSample, SensorData, TrainingJob
from config import ADMIN_API_KEY
import logging

# 创建表
Base.metadata.create_all(bind=engine)

# 初始化FastAPI
app = FastAPI(
    title="Fall Detection Training API",
    version="1.0.0"
)

# CORS中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ========== 数据模型 ==========

class SensorDataPoint(BaseModel):
    timestamp: int
    acc: dict  # {x, y, z}
    gyro: dict  # {x, y, z}

class UploadDataRequest(BaseModel):
    user_id: str
    label: str  # 'fall' or 'normal'
    source: str  # 'simulate' or 'riding'
    duration: int
    samples: List[SensorDataPoint]
    metadata: Optional[dict] = None

# ========== API接口 ==========

@app.get("/")
def root():
    return {"message": "Fall Detection Training API", "version": "1.0.0"}

@app.get("/api/health")
def health_check():
    return {
        "status": "healthy",
        "timestamp": func.now()
    }

@app.post("/api/upload/training-data")
async def upload_training_data(
    request: UploadDataRequest,
    db: Session = Depends(get_db)
):
    """上传训练数据"""
    try:
        logger.info(f"接收数据: user={request.user_id}, label={request.label}, samples={len(request.samples)}")

        # 验证数据
        if request.label not in ['fall', 'normal']:
            raise HTTPException(status_code=400, detail="label must be 'fall' or 'normal'")

        if request.source not in ['simulate', 'riding']:
            raise HTTPException(status_code=400, detail="source must be 'simulate' or 'riding'")

        if len(request.samples) == 0:
            raise HTTPException(status_code=400, detail="samples cannot be empty")

        # 创建样本记录
        sample = TrainingSample(
            user_id=request.user_id,
            label=request.label,
            source=request.source,
            duration=request.duration,
            sample_count=len(request.samples),
            metadata=request.metadata
        )
        db.add(sample)
        db.commit()
        db.refresh(sample)

        # 批量插入传感器数据
        sensor_data_list = []
        for point in request.samples:
            sensor_data_list.append(SensorData(
                sample_id=sample.id,
                timestamp=point.timestamp,
                acc_x=point.acc['x'],
                acc_y=point.acc['y'],
                acc_z=point.acc['z'],
                gyro_x=point.gyro['x'],
                gyro_y=point.gyro['y'],
                gyro_z=point.gyro['z']
            ))

        db.bulk_save_objects(sensor_data_list)
        db.commit()

        logger.info(f"数据保存成功: sample_id={sample.id}")

        return {
            "success": True,
            "message": "数据上传成功",
            "data": {
                "sample_id": sample.id,
                "sample_count": len(request.samples),
                "created_at": sample.uploaded_at
            }
        }

    except Exception as e:
        logger.error(f"上传失败: {e}")
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/data/stats")
def get_data_stats(
    x_api_key: str = Header(...),
    db: Session = Depends(get_db)
):
    """获取数据统计（需要API Key）"""
    if x_api_key != ADMIN_API_KEY:
        raise HTTPException(status_code=401, detail="Unauthorized")

    try:
        total = db.query(TrainingSample).count()
        fall_count = db.query(TrainingSample).filter(TrainingSample.label == 'fall').count()
        normal_count = db.query(TrainingSample).filter(TrainingSample.label == 'normal').count()

        return {
            "success": True,
            "data": {
                "total_samples": total,
                "fall_samples": fall_count,
                "normal_samples": normal_count
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/training/start")
async def start_training(
    x_api_key: str = Header(...),
    db: Session = Depends(get_db)
):
    """启动训练任务（需要API Key）"""
    if x_api_key != ADMIN_API_KEY:
        raise HTTPException(status_code=401, detail="Unauthorized")

    try:
        # 检查是否有正在运行的任务
        running_job = db.query(TrainingJob).filter(
            TrainingJob.status.in_(['pending', 'running'])
        ).first()

        if running_job:
            raise HTTPException(status_code=409, detail="已有训练任务正在运行")

        # 创建新任务
        job = TrainingJob(
            algorithm='random_forest',
            status='pending'
        )
        db.add(job)
        db.commit()
        db.refresh(job)

        # TODO: 这里应该启动异步训练任务
        # 可以使用Celery或直接使用asyncio

        return {
            "success": True,
            "message": "训练任务已创建",
            "data": {
                "job_id": job.id,
                "status": job.status
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"创建训练任务失败: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 7. 启动后端

```bash
# 运行FastAPI
python main.py

# 或使用uvicorn
uvicorn main:app --reload --host 0.0.0.0 --port 8000

# 访问API文档
# http://localhost:8000/docs
```

---

## 第二部分：特征工程与模型训练

### 8. training/feature_extraction.py

```python
import numpy as np
import pandas as pd
from scipy import stats
from scipy.fft import fft

class FeatureExtractor:
    """特征提取器"""

    def __init__(self, window_size=100, overlap=50):
        """
        Args:
            window_size: 窗口大小（数据点数）
            overlap: 重叠数据点数
        """
        self.window_size = window_size
        self.overlap = overlap
        self.step = window_size - overlap

    def extract_features(self, sensor_data):
        """
        从传感器数据中提取特征

        Args:
            sensor_data: DataFrame，包含[acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z]

        Returns:
            features: numpy array，形状为 (n_windows, n_features)
        """
        features_list = []

        # 滑动窗口
        for i in range(0, len(sensor_data) - self.window_size, self.step):
            window = sensor_data.iloc[i:i + self.window_size]

            # 提取特征
            features = self._extract_window_features(window)
            features_list.append(features)

        return np.array(features_list)

    def _extract_window_features(self, window):
        """提取单个窗口的特征"""
        features = []

        # 对每个传感器轴提取特征
        for col in window.columns:
            data = window[col].values

            # 时域特征
            features.extend([
                np.mean(data),              # 均值
                np.std(data),               # 标准差
                np.min(data),               # 最小值
                np.max(data),               # 最大值
                np.ptp(data),               # 极差
                np.sqrt(np.mean(data**2)),  # RMS
                stats.skew(data),           # 偏度
                stats.kurtosis(data),       # 峰度
            ])

            # 频域特征（FFT）
            fft_vals = np.abs(fft(data))[:len(data)//2]
            features.extend([
                np.sum(fft_vals),           # 频谱能量
                np.argmax(fft_vals),        # 主频率索引
            ])

        # 合成特征
        acc_magnitude = np.sqrt(
            window['acc_x']**2 +
            window['acc_y']**2 +
            window['acc_z']**2
        )
        gyro_magnitude = np.sqrt(
            window['gyro_x']**2 +
            window['gyro_y']**2 +
            window['gyro_z']**2
        )

        features.extend([
            np.mean(acc_magnitude),
            np.max(acc_magnitude),
            np.mean(gyro_magnitude),
            np.max(gyro_magnitude),
        ])

        return features

# 总特征数：6轴 × 10特征/轴 + 4合成特征 = 64维
```

### 9. training/train_model.py

```python
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sqlalchemy import create_engine
from feature_extraction import FeatureExtractor
import joblib
import logging

logger = logging.getLogger(__name__)

class ModelTrainer:
    """模型训练器"""

    def __init__(self, db_url):
        self.db_url = db_url
        self.engine = create_engine(db_url)
        self.feature_extractor = FeatureExtractor(window_size=100, overlap=50)
        self.model = None

    def load_data_from_db(self):
        """从数据库加载数据"""
        logger.info("从数据库加载数据...")

        # 加载样本元数据
        samples_query = """
        SELECT id, label
        FROM training_samples
        WHERE processed = FALSE
        """
        samples_df = pd.read_sql(samples_query, self.engine)

        logger.info(f"加载了 {len(samples_df)} 个样本")

        X_list = []
        y_list = []

        # 对每个样本提取特征
        for _, sample in samples_df.iterrows():
            sample_id = sample['id']
            label = 1 if sample['label'] == 'fall' else 0

            # 加载传感器数据
            sensor_query = f"""
            SELECT acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z
            FROM sensor_data
            WHERE sample_id = {sample_id}
            ORDER BY timestamp ASC
            """
            sensor_data = pd.read_sql(sensor_query, self.engine)

            if len(sensor_data) < 100:
                continue  # 跳过数据不足的样本

            # 提取特征
            features = self.feature_extractor.extract_features(sensor_data)

            # 添加到列表
            for feature_vec in features:
                X_list.append(feature_vec)
                y_list.append(label)

        X = np.array(X_list)
        y = np.array(y_list)

        logger.info(f"提取了 {len(X)} 个特征向量")
        return X, y

    def train(self, X, y, test_size=0.2):
        """训练模型"""
        logger.info("开始训练模型...")

        # 划分数据集
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=test_size, random_state=42, stratify=y
        )

        logger.info(f"训练集: {len(X_train)}, 测试集: {len(X_test)}")

        # 训练Random Forest
        self.model = RandomForestClassifier(
            n_estimators=100,
            max_depth=20,
            random_state=42,
            n_jobs=-1
        )

        self.model.fit(X_train, y_train)

        # 评估
        y_pred = self.model.predict(X_test)

        metrics = {
            'accuracy': accuracy_score(y_test, y_pred),
            'precision': precision_score(y_test, y_pred),
            'recall': recall_score(y_test, y_pred),
            'f1_score': f1_score(y_test, y_pred),
        }

        logger.info(f"训练完成: {metrics}")
        return metrics

    def save_model(self, path):
        """保存模型"""
        if self.model is None:
            raise ValueError("模型尚未训练")

        joblib.dump(self.model, path)
        logger.info(f"模型已保存到: {path}")

# 使用示例
if __name__ == "__main__":
    trainer = ModelTrainer(db_url='mysql+pymysql://root:password@localhost/fall_detection_training')
    X, y = trainer.load_data_from_db()
    metrics = trainer.train(X, y)
    trainer.save_model('./models/fall_detection_rf.pkl')
```

---

## 第三部分：小程序实现

### 10. 模拟摔倒页面 pages/simulate/simulate.vue

```vue
<template>
  <view class="simulate-page">
    <view class="header">
      <text class="title">模拟摔倒数据采集</text>
    </view>

    <view class="content">
      <!-- 状态显示 -->
      <view class="status-card" v-if="!isCollecting && !isFinished">
        <text class="desc">点击"开始采集"按钮，然后进行模拟摔倒动作。</text>
        <text class="desc">采集时长：30秒</text>
      </view>

      <!-- 采集中 -->
      <view class="collecting-card" v-if="isCollecting">
        <view class="timer">{{ countdown }}s</view>
        <text class="status-text">采集中... 请进行模拟动作</text>
        <view class="sample-count">已采集: {{ sampleCount }} 个数据点</view>

        <progress
          :percent="progress"
          stroke-width="8"
          activeColor="#3B82F6"
          backgroundColor="#E5E7EB"
        />
      </view>

      <!-- 采集完成 -->
      <view class="finished-card" v-if="isFinished">
        <m-icon name="check_circle" :size="80" color="#10B981"></m-icon>
        <text class="success-text">采集完成！</text>
        <text class="info">共采集 {{ sampleCount }} 个数据点</text>

        <text class="question">请问刚才是否进行了摔倒动作？</text>

        <view class="button-group">
          <button class="action-btn fall-btn" @click="labelAndUpload('fall')">
            是的，摔倒了
          </button>
          <button class="action-btn normal-btn" @click="labelAndUpload('normal')">
            没有，正常动作
          </button>
        </view>

        <button class="cancel-btn" @click="reset">取消上传</button>
      </view>

      <!-- 控制按钮 -->
      <view class="control-section" v-if="!isCollecting && !isFinished">
        <button class="start-btn" @click="startCollection">
          <m-icon name="play_arrow" :size="32" color="#FFFFFF"></m-icon>
          <text>开始采集（30秒）</text>
        </button>
      </view>
    </view>
  </view>
</template>

<script setup>
import { ref, computed, onUnmounted } from 'vue';
import dataCollector from '@/utils/dataCollector.js';

// 状态
const isCollecting = ref(false);
const isFinished = ref(false);
const countdown = ref(30);
const sampleCount = ref(0);

// 定时器
let countdownTimer = null;
let statusTimer = null;

// 进度
const progress = computed(() => {
  return ((30 - countdown.value) / 30) * 100;
});

// 开始采集
const startCollection = () => {
  isCollecting.value = true;
  countdown.value = 30;
  sampleCount.value = 0;

  // 启动数据收集器
  dataCollector.startCollection();

  // 倒计时
  countdownTimer = setInterval(() => {
    countdown.value--;

    if (countdown.value <= 0) {
      stopCollection();
    }
  }, 1000);

  // 更新样本数量
  statusTimer = setInterval(() => {
    const status = dataCollector.getStatus();
    sampleCount.value = status.sampleCount;
  }, 100);

  uni.showToast({
    title: '开始采集',
    icon: 'success'
  });
};

// 停止采集
const stopCollection = () => {
  clearInterval(countdownTimer);
  clearInterval(statusTimer);

  const result = dataCollector.stopCollection();
  sampleCount.value = result.sampleCount;

  isCollecting.value = false;
  isFinished.value = true;

  uni.vibrateShort();
};

// 标注并上传
const labelAndUpload = async (label) => {
  uni.showLoading({ title: '上传中...' });

  try {
    const result = await dataCollector.uploadData(label, 'simulate');

    if (result.success) {
      uni.showToast({
        title: '上传成功',
        icon: 'success'
      });

      // 延迟返回
      setTimeout(() => {
        uni.navigateBack();
      }, 1500);
    } else {
      uni.showToast({
        title: result.error || '上传失败',
        icon: 'none'
      });
    }
  } catch (err) {
    uni.showToast({
      title: '上传失败',
      icon: 'none'
    });
  } finally {
    uni.hideLoading();
  }
};

// 重置
const reset = () => {
  dataCollector.clear();
  isCollecting.value = false;
  isFinished.value = false;
  countdown.value = 30;
  sampleCount.value = 0;
};

// 清理
onUnmounted(() => {
  if (countdownTimer) clearInterval(countdownTimer);
  if (statusTimer) clearInterval(statusTimer);
  dataCollector.stopCollection();
});
</script>

<style lang="scss" scoped>
.simulate-page {
  min-height: 100vh;
  background: #F3F4F6;
  padding: 32rpx;
}

.header {
  padding: 32rpx;
  text-align: center;

  .title {
    font-size: 40rpx;
    font-weight: 700;
    color: #1F2937;
  }
}

.status-card,
.collecting-card,
.finished-card {
  background: white;
  border-radius: 24rpx;
  padding: 64rpx 32rpx;
  text-align: center;
  box-shadow: 0 4rpx 24rpx rgba(0, 0, 0, 0.08);
  margin-bottom: 32rpx;
}

.timer {
  font-size: 120rpx;
  font-weight: 700;
  color: #3B82F6;
  margin-bottom: 32rpx;
}

.status-text {
  font-size: 32rpx;
  color: #6B7280;
  margin-bottom: 16rpx;
}

.sample-count {
  font-size: 28rpx;
  color: #9CA3AF;
  margin: 32rpx 0;
}

.success-text {
  display: block;
  font-size: 40rpx;
  font-weight: 700;
  color: #10B981;
  margin: 32rpx 0;
}

.question {
  display: block;
  font-size: 32rpx;
  color: #374151;
  margin: 48rpx 0 32rpx 0;
}

.button-group {
  display: flex;
  flex-direction: column;
  gap: 24rpx;
  margin-bottom: 24rpx;
}

.action-btn {
  height: 96rpx;
  border-radius: 16rpx;
  font-size: 32rpx;
  font-weight: 600;
  color: white;
  border: none;

  &::after {
    border: none;
  }

  &.fall-btn {
    background: #EF4444;
  }

  &.normal-btn {
    background: #3B82F6;
  }
}

.cancel-btn {
  height: 80rpx;
  border-radius: 16rpx;
  font-size: 28rpx;
  color: #6B7280;
  background: #F3F4F6;
  border: none;

  &::after {
    border: none;
  }
}

.start-btn {
  width: 100%;
  height: 120rpx;
  border-radius: 24rpx;
  background: #3B82F6;
  color: white;
  font-size: 36rpx;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16rpx;
  border: none;

  &::after {
    border: none;
  }
}
</style>
```

---

## 快速开始步骤

### 步骤1：数据库初始化
```bash
mysql -u root -p
CREATE DATABASE fall_detection_training;
USE fall_detection_training;
SOURCE docs/train/02-数据库设计.md  # 执行建表SQL
```

### 步骤2：启动后端
```bash
cd backend
python main.py
```

### 步骤3：小程序配置
在 `utils/config.js` 中根据环境调整 `API_BASE_URL`：
```javascript
const devConfig = {
  API_BASE_URL: 'http://your-server-ip:8000/api',
  // ...其他开发环境配置
};

const prodConfig = {
  API_BASE_URL: 'https://your-production-domain.com/api',
  // ...其他生产环境配置
};
```

### 步骤4：开始收集数据
1. 在小程序中进入"模拟摔倒"页面
2. 点击"开始采集"
3. 进行模拟动作（30秒）
4. 标注并上传

### 步骤5：训练模型
```bash
cd backend/training
python train_model.py
```

---

## 测试接口

```bash
# 测试上传
curl -X POST http://localhost:8000/api/upload/training-data \
  -H "Content-Type: application/json" \
  -d @test_data.json

# 查询统计
curl -X GET http://localhost:8000/api/data/stats \
  -H "X-API-Key: your-api-key"
```

---

## 完成✅

现在你已经拥有：
- ✅ FastAPI后端服务
- ✅ MySQL数据库
- ✅ 数据收集器（小程序）
- ✅ 模拟摔倒页面
- ✅ 特征提取代码
- ✅ 模型训练代码

下一步：收集100+摔倒样本和1000+正常样本，然后开始训练！
