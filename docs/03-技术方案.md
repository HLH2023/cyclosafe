# 技术方案文档

## 一、技术栈选型

### 1.1 开发框架

#### uniapp
- **版本要求**：>= 3.0
- **选择理由**：
  - 跨平台支持（小程序、H5、App）
  - Vue.js开发体验友好
  - 完整的微信小程序API封装
  - 活跃的社区和丰富的插件
  - 官方维护，稳定性高

#### Vue.js
- **版本**：Vue 3
- **语法**：Composition API + Options API
- **用途**：组件化开发，状态管理

### 1.2 开发语言

- **主要语言**：JavaScript / TypeScript
- **样式语言**：SCSS / CSS
- **模板语言**：Vue Template

### 1.3 目标平台

- **主平台**：微信小程序
- **扩展平台**：支付宝小程序、H5（可选）

---

## 二、系统架构

### 2.1 架构模式

采用 **纯客户端架构**（Client-Only Architecture）

```
┌─────────────────────────────────────┐
│           用户界面层 (UI Layer)       │
│  ┌──────┐ ┌──────┐ ┌──────┐        │
│  │ 骑行  │ │ 分析  │ │ 设置  │        │
│  │ 页面  │ │ 页面  │ │ 页面  │        │
│  └──────┘ └──────┘ └──────┘        │
└──────────────┬──────────────────────┘
               │
┌──────────────┴──────────────────────┐
│         业务逻辑层 (Logic Layer)      │
│  ┌──────────┐ ┌──────────┐         │
│  │ 骑行管理  │ │ 数据计算  │         │
│  │ 服务      │ │ 服务      │         │
│  └──────────┘ └──────────┘         │
│  ┌──────────┐ ┌──────────┐         │
│  │ 安全检测  │ │ 地图管理  │         │
│  │ 服务      │ │ 服务      │         │
│  └──────────┘ └──────────┘         │
└──────────────┬──────────────────────┘
               │
┌──────────────┴──────────────────────┐
│         数据层 (Data Layer)          │
│  ┌──────────┐ ┌──────────┐         │
│  │ 本地存储  │ │ 状态管理  │         │
│  │ Storage   │ │ Store     │         │
│  └──────────┘ └──────────┘         │
└──────────────┬──────────────────────┘
               │
┌──────────────┴──────────────────────┐
│       硬件接口层 (Hardware Layer)     │
│  ┌─────┐ ┌──────┐ ┌──────┐         │
│  │ GPS  │ │ 加速度│ │ 陀螺仪│         │
│  └─────┘ └──────┘ └──────┘         │
│  ┌─────┐ ┌──────┐ ┌──────┐         │
│  │ 罗盘  │ │ 震动  │ │ 地图  │         │
│  └─────┘ └──────┘ └──────┘         │
└─────────────────────────────────────┘
```

### 2.2 目录结构

```
mobileHomework/
├── docs/                    # 项目文档
│   ├── 01-项目概述.md
│   ├── 02-功能需求.md
│   ├── 03-技术方案.md
│   ├── 04-硬件接口使用.md
│   ├── 05-第三方依赖.md
│   └── 06-开发计划.md
│
├── src/                     # 源代码目录
│   ├── pages/               # 页面
│   │   ├── index/           # 首页
│   │   │   ├── index.vue
│   │   │   └── index.scss
│   │   ├── riding/          # 骑行页面
│   │   │   ├── riding.vue
│   │   │   └── riding.scss
│   │   ├── analysis/        # 数据分析页面
│   │   │   ├── analysis.vue
│   │   │   └── analysis.scss
│   │   ├── history/         # 历史记录页面
│   │   │   ├── history.vue
│   │   │   └── history.scss
│   │   └── settings/        # 设置页面
│   │       ├── settings.vue
│   │       └── settings.scss
│   │
│   ├── components/          # 公共组件
│   │   ├── Speedometer/     # 速度表组件
│   │   │   └── Speedometer.vue
│   │   ├── MapView/         # 地图组件
│   │   │   └── MapView.vue
│   │   ├── Chart/           # 图表组件
│   │   │   ├── SpeedChart.vue
│   │   │   └── AltitudeChart.vue
│   │   └── RidingCard/      # 骑行记录卡片
│   │       └── RidingCard.vue
│   │
│   ├── services/            # 业务逻辑层
│   │   ├── ridingService.js # 骑行管理服务
│   │   ├── gpsService.js    # GPS服务
│   │   ├── sensorService.js # 传感器服务
│   │   ├── mapService.js    # 地图服务
│   │   └── safetyService.js # 安全检测服务
│   │
│   ├── utils/               # 工具函数
│   │   ├── gpsCalculator.js # GPS计算工具
│   │   ├── dataProcessor.js # 数据处理工具
│   │   ├── gpxExporter.js   # GPX导出工具
│   │   ├── storage.js       # 本地存储工具
│   │   └── constants.js     # 常量定义
│   │
│   ├── store/               # 状态管理
│   │   ├── index.js         # Store入口
│   │   ├── ridingStore.js   # 骑行状态
│   │   └── settingsStore.js # 设置状态
│   │
│   ├── static/              # 静态资源
│   │   ├── images/          # 图片
│   │   └── icons/           # 图标
│   │
│   ├── App.vue              # 应用入口
│   ├── main.js              # 主入口文件
│   ├── manifest.json        # 应用配置
│   ├── pages.json           # 页面配置
│   └── uni.scss             # 全局样式
│
├── .gitignore
├── package.json
└── README.md
```

---

## 三、核心技术方案

### 3.1 GPS定位与轨迹记录

#### 3.1.1 定位方案

**使用API**：`uni.getLocation()` + `uni.startLocationUpdate()`

**定位策略**：
```javascript
// 1. 初始定位（获取当前位置）
uni.getLocation({
  type: 'gcj02',        // 国测局坐标系
  altitude: true,       // 包含海拔
  isHighAccuracy: true, // 高精度模式
  success: (res) => {
    // 处理位置数据
  }
});

// 2. 持续定位（骑行中）
uni.startLocationUpdate({
  type: 'gcj02',
  success: () => {
    uni.onLocationChange((res) => {
      // 实时处理位置变化
    });
  }
});
```

**优化措施**：
- 使用gcj02坐标系（避免偏移）
- 开启高精度模式
- 设置最小更新距离（5米）
- 设置最小更新时间（3秒）

#### 3.1.2 轨迹算法

**距离计算 - Haversine公式**：
```javascript
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // 地球半径（公里）
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) *
            Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distance = R * c;

  return distance; // 单位：公里
}
```

**速度计算**：
```javascript
function calculateSpeed(distance, timeInterval) {
  // distance: 米
  // timeInterval: 秒
  const speedMps = distance / timeInterval; // m/s
  const speedKmh = speedMps * 3.6;          // km/h
  return speedKmh;
}
```

**轨迹点过滤**：
- 精度过滤：GPS精度 < 50米才记录
- 距离过滤：与上一点距离 > 5米
- 时间过滤：与上一点时间 > 3秒
- 速度过滤：速度 > 1 km/h（排除静止）

#### 3.1.3 数据结构

**轨迹点数据**：
```javascript
interface TrackPoint {
  latitude: number;      // 纬度
  longitude: number;     // 经度
  altitude: number;      // 海拔（米）
  speed: number;         // 速度（km/h）
  accuracy: number;      // 精度（米）
  timestamp: number;     // 时间戳（毫秒）
  distance: number;      // 累计距离（公里）
}
```

**骑行记录数据**：
```javascript
interface RidingRecord {
  id: string;            // 记录ID（UUID）
  startTime: number;     // 开始时间
  endTime: number;       // 结束时间
  duration: number;      // 骑行时长（秒）
  distance: number;      // 总距离（公里）
  avgSpeed: number;      // 平均速度
  maxSpeed: number;      // 最高速度
  startAltitude: number; // 起始海拔
  maxAltitude: number;   // 最高海拔
  totalAscent: number;   // 总爬升（米）
  totalDescent: number;  // 总下降（米）
  trackPoints: TrackPoint[]; // 轨迹点数组
  dangerPoints: DangerPoint[]; // 危险点数组
}
```

### 3.2 传感器数据处理

#### 3.2.1 加速度计

**监听API**：
```javascript
uni.startAccelerometer({
  interval: 'game', // 20ms采样（50Hz）
  success: () => {
    uni.onAccelerometerChange((res) => {
      const { x, y, z } = res;
      // 处理加速度数据
    });
  }
});
```

**数据处理**：
```javascript
// 计算合加速度
function calculateTotalAcceleration(x, y, z) {
  return Math.sqrt(x * x + y * y + z * z);
}

// 移动平均滤波（平滑数据）
class MovingAverageFilter {
  constructor(windowSize = 5) {
    this.buffer = [];
    this.windowSize = windowSize;
  }

  filter(value) {
    this.buffer.push(value);
    if (this.buffer.length > this.windowSize) {
      this.buffer.shift();
    }
    return this.buffer.reduce((a, b) => a + b) / this.buffer.length;
  }
}
```

**急刹车检测算法**：
```javascript
function detectHardBraking(accelerationData, speedData) {
  const ACC_THRESHOLD = 6; // m/s²
  const SPEED_DROP_THRESHOLD = 15; // km/h/s

  // 检测加速度突变
  const totalAcc = calculateTotalAcceleration(
    accelerationData.x,
    accelerationData.y,
    accelerationData.z
  );

  // 检测速度骤降
  const speedDrop = (speedData.previous - speedData.current) /
                    (speedData.timeInterval / 1000);

  return totalAcc > ACC_THRESHOLD ||
         Math.abs(speedDrop) > SPEED_DROP_THRESHOLD;
}
```

#### 3.2.2 陀螺仪

**监听API**：
```javascript
uni.startGyroscope({
  interval: 'game', // 20ms采样
  success: () => {
    uni.onGyroscopeChange((res) => {
      const { x, y, z } = res; // 角速度（°/s）
      // 处理陀螺仪数据
    });
  }
});
```

**摔倒检测算法**：
```javascript
function detectFalling(accData, gyroData) {
  const ACC_THRESHOLD = 15;  // 加速度阈值（m/s²）
  const GYRO_THRESHOLD = 200; // 角速度阈值（°/s）

  // 检测冲击（加速度峰值）
  const totalAcc = calculateTotalAcceleration(
    accData.x, accData.y, accData.z
  );

  // 检测翻转（角速度峰值）
  const totalGyro = Math.sqrt(
    gyroData.x ** 2 + gyroData.y ** 2 + gyroData.z ** 2
  );

  // 综合判断
  return totalAcc > ACC_THRESHOLD && totalGyro > GYRO_THRESHOLD;
}
```

#### 3.2.3 罗盘（指南针）

**监听API**：
```javascript
uni.startCompass({
  success: () => {
    uni.onCompassChange((res) => {
      const direction = res.direction; // 方向角（0-360°）
      // 显示方向指示
    });
  }
});
```

**方向显示**：
```javascript
function getDirectionName(degree) {
  const directions = [
    '北', '东北', '东', '东南',
    '南', '西南', '西', '西北'
  ];
  const index = Math.round(degree / 45) % 8;
  return directions[index];
}
```

### 3.3 地图集成方案

#### 3.3.1 地图SDK选择

**推荐：腾讯位置服务**

**申请密钥**：
1. 注册腾讯位置服务账号
2. 创建应用
3. 获取Key（微信小程序）

**配置manifest.json**：
```json
{
  "mp-weixin": {
    "permission": {
      "scope.userLocation": {
        "desc": "用于记录骑行轨迹和提供位置服务"
      }
    },
    "requiredPrivateInfos": [
      "getLocation",
      "onLocationChange",
      "startLocationUpdate"
    ]
  }
}
```

#### 3.3.2 地图组件使用

**基础地图**：
```vue
<template>
  <map
    id="riding-map"
    :longitude="currentLocation.longitude"
    :latitude="currentLocation.latitude"
    :scale="15"
    :markers="markers"
    :polyline="polyline"
    :show-location="true"
    style="width: 100%; height: 400px;"
  />
</template>

<script>
export default {
  data() {
    return {
      currentLocation: {
        longitude: 0,
        latitude: 0
      },
      markers: [], // 标记点
      polyline: [] // 轨迹线
    };
  }
};
</script>
```

**轨迹绘制**：
```javascript
function generatePolyline(trackPoints) {
  return [{
    points: trackPoints.map(p => ({
      latitude: p.latitude,
      longitude: p.longitude
    })),
    color: '#3388FF',
    width: 6,
    arrowLine: true,
    borderColor: '#FFFFFF',
    borderWidth: 2
  }];
}
```

**颜色编码（速度）**：
```javascript
function getColorBySpeed(speed) {
  if (speed < 15) return '#22C55E'; // 绿色
  if (speed < 25) return '#3B82F6'; // 蓝色
  return '#EF4444';                 // 红色
}

function generateColoredPolyline(trackPoints) {
  const segments = [];
  for (let i = 0; i < trackPoints.length - 1; i++) {
    segments.push({
      points: [
        { latitude: trackPoints[i].latitude,
          longitude: trackPoints[i].longitude },
        { latitude: trackPoints[i+1].latitude,
          longitude: trackPoints[i+1].longitude }
      ],
      color: getColorBySpeed(trackPoints[i].speed),
      width: 6
    });
  }
  return segments;
}
```

### 3.4 数据可视化方案

#### 3.4.1 图表库选择

**推荐：uCharts**

**安装**：
```bash
npm install @qiun/ucharts
```

**特点**：
- 专为uniapp优化
- 体积小（约50KB）
- 性能好
- 支持多种图表类型

#### 3.4.2 速度曲线图

```vue
<template>
  <view class="chart-container">
    <qiun-ucharts
      type="line"
      :chartData="speedChartData"
      :opts="speedChartOpts"
    />
  </view>
</template>

<script>
export default {
  data() {
    return {
      speedChartData: {
        categories: [], // 时间轴
        series: [{
          name: '速度',
          data: []        // 速度数据
        }]
      },
      speedChartOpts: {
        color: ['#3B82F6'],
        padding: [15, 15, 0, 15],
        xAxis: {
          disableGrid: true,
          title: '时间'
        },
        yAxis: {
          title: '速度 (km/h)',
          min: 0
        },
        extra: {
          line: {
            type: 'curve',
            width: 2
          }
        }
      }
    };
  },
  methods: {
    loadChartData(trackPoints) {
      this.speedChartData.categories = trackPoints.map((p, i) =>
        formatTime(i * 3) // 每3秒一个点
      );
      this.speedChartData.series[0].data = trackPoints.map(p =>
        p.speed
      );
    }
  }
};
</script>
```

#### 3.4.3 海拔曲线图

```javascript
{
  type: 'area',
  data: {
    categories: [], // 距离轴（km）
    series: [{
      name: '海拔',
      data: []        // 海拔数据（m）
    }]
  },
  opts: {
    color: ['#10B981'],
    xAxis: { title: '距离 (km)' },
    yAxis: { title: '海拔 (m)' },
    extra: {
      area: {
        type: 'curve',
        opacity: 0.3,
        gradient: true
      }
    }
  }
}
```

### 3.5 数据存储方案

#### 3.5.1 本地存储

**使用API**：`uni.setStorage` / `uni.getStorage`

**存储策略**：
```javascript
// 存储工具类
class StorageService {
  // 保存骑行记录
  static saveRidingRecord(record) {
    const key = `riding_${record.id}`;
    uni.setStorageSync(key, JSON.stringify(record));

    // 更新记录列表
    const list = this.getRecordList();
    list.unshift(record.id);
    uni.setStorageSync('riding_list', JSON.stringify(list));
  }

  // 获取骑行记录
  static getRidingRecord(id) {
    const key = `riding_${id}`;
    const data = uni.getStorageSync(key);
    return data ? JSON.parse(data) : null;
  }

  // 获取记录列表
  static getRecordList() {
    const data = uni.getStorageSync('riding_list');
    return data ? JSON.parse(data) : [];
  }

  // 删除记录
  static deleteRecord(id) {
    const key = `riding_${id}`;
    uni.removeStorageSync(key);

    const list = this.getRecordList();
    const newList = list.filter(item => item !== id);
    uni.setStorageSync('riding_list', JSON.stringify(newList));
  }

  // 保存设置
  static saveSetting(key, value) {
    uni.setStorageSync(`setting_${key}`, value);
  }

  // 获取设置
  static getSetting(key, defaultValue) {
    const value = uni.getStorageSync(`setting_${key}`);
    return value !== '' ? value : defaultValue;
  }
}
```

**数据压缩**：
```javascript
// 轨迹点压缩（Douglas-Peucker算法）
function compressTrackPoints(points, tolerance = 0.0001) {
  if (points.length <= 2) return points;

  // 实现Douglas-Peucker算法
  // 减少轨迹点数量，保持轨迹形状
}
```

#### 3.5.2 状态管理

**使用Pinia（Vue 3推荐）**：

```javascript
// store/ridingStore.js
import { defineStore } from 'pinia';

export const useRidingStore = defineStore('riding', {
  state: () => ({
    isRiding: false,
    isPaused: false,
    startTime: 0,
    duration: 0,
    distance: 0,
    currentSpeed: 0,
    avgSpeed: 0,
    maxSpeed: 0,
    altitude: 0,
    totalAscent: 0,
    totalDescent: 0,
    trackPoints: []
  }),

  actions: {
    startRiding() {
      this.isRiding = true;
      this.startTime = Date.now();
      // 初始化数据
    },

    pauseRiding() {
      this.isPaused = true;
    },

    resumeRiding() {
      this.isPaused = false;
    },

    stopRiding() {
      this.isRiding = false;
      // 保存数据
    },

    updateLocation(location) {
      // 更新位置数据
      this.trackPoints.push(location);
      // 计算速度、距离等
    }
  }
});
```

### 3.6 GPX导出方案

#### 3.6.1 GPX格式

```xml
<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="CycloSafe">
  <metadata>
    <name>骑行记录 2025-10-02</name>
    <time>2025-10-02T14:32:00Z</time>
  </metadata>
  <trk>
    <name>CycloSafe Riding</name>
    <trkseg>
      <trkpt lat="39.9042" lon="116.4074">
        <ele>50.0</ele>
        <time>2025-10-02T14:32:00Z</time>
      </trkpt>
      <!-- 更多轨迹点 -->
    </trkseg>
  </trk>
</gpx>
```

#### 3.6.2 导出实现

```javascript
// utils/gpxExporter.js
class GPXExporter {
  static export(record) {
    const gpxContent = this.generateGPX(record);
    const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });

    // 小程序环境：转换为base64分享
    return this.blobToBase64(blob);
  }

  static generateGPX(record) {
    const { trackPoints, startTime } = record;

    let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="CycloSafe">
  <metadata>
    <name>骑行记录 ${formatDate(startTime)}</name>
    <time>${new Date(startTime).toISOString()}</time>
  </metadata>
  <trk>
    <name>CycloSafe Riding</name>
    <trkseg>`;

    trackPoints.forEach(point => {
      gpx += `
      <trkpt lat="${point.latitude}" lon="${point.longitude}">
        <ele>${point.altitude}</ele>
        <time>${new Date(point.timestamp).toISOString()}</time>
      </trkpt>`;
    });

    gpx += `
    </trkseg>
  </trk>
</gpx>`;

    return gpx;
  }
}
```

---

## 四、性能优化方案

### 4.1 GPS性能优化

**1. 智能采样**
```javascript
// 动态调整采样频率
function adjustSamplingRate(speed) {
  if (speed < 10) return 5000;  // 低速：5秒
  if (speed < 25) return 3000;  // 中速：3秒
  return 1000;                   // 高速：1秒
}
```

**2. 轨迹点过滤**
- 精度过滤（accuracy < 50m）
- 距离过滤（distance > 5m）
- 速度过滤（speed > 1 km/h）

### 4.2 电池优化

**1. 暂停时停止定位**
```javascript
if (isPaused) {
  uni.stopLocationUpdate();
  uni.stopAccelerometer();
  uni.stopGyroscope();
}
```

**2. 降低传感器采样率**
```javascript
// 使用'ui'频率（60Hz）而非'game'频率（20Hz）
uni.startAccelerometer({ interval: 'ui' });
```

### 4.3 内存优化

**1. 轨迹点限制**
```javascript
// 最多保存10000个点
if (trackPoints.length > 10000) {
  trackPoints = compressTrackPoints(trackPoints);
}
```

**2. 图片懒加载**
```vue
<image
  :src="imageSrc"
  lazy-load
  mode="aspectFill"
/>
```

### 4.4 渲染优化

**1. 虚拟列表**（历史记录）
```vue
<recycle-list :list="historyList" />
```

**2. 节流与防抖**
```javascript
// 地图更新节流
const updateMap = throttle(() => {
  // 更新地图
}, 1000);

// 搜索防抖
const search = debounce(() => {
  // 执行搜索
}, 300);
```

---

## 五、安全与隐私

### 5.1 数据安全

- 所有数据存储在本地
- 不上传到任何服务器
- 用户完全控制数据

### 5.2 权限申请

```javascript
// 位置权限
uni.authorize({
  scope: 'scope.userLocation',
  success: () => {
    // 开始定位
  }
});
```

### 5.3 异常处理

```javascript
// GPS定位失败
uni.getLocation({
  fail: (err) => {
    uni.showModal({
      title: '定位失败',
      content: '请检查GPS是否开启，并授权位置权限'
    });
  }
});

// 传感器不可用
uni.startAccelerometer({
  fail: (err) => {
    console.error('加速度计不可用', err);
  }
});
```

---

## 六、测试方案

### 6.1 功能测试

- GPS精度测试（实际骑行对比）
- 传感器灵敏度测试
- 电池消耗测试
- 兼容性测试

### 6.2 真机调试

**必须真机测试的功能**：
- GPS定位
- 加速度计、陀螺仪
- 摔倒检测
- 电池消耗

**测试设备**：
- Android手机（>= 6.0）
- iPhone（>= 10.0）

---

## 七、技术难点与解决方案

### 7.1 GPS精度问题

**问题**：GPS漂移，轨迹不准

**解决方案**：
- 使用Kalman滤波平滑轨迹
- 过滤低精度点
- 路径吸附（可选）

### 7.2 摔倒误检测

**问题**：急刹车被误判为摔倒

**解决方案**：
- 多传感器融合（加速度+陀螺仪）
- 设置灵敏度调节
- 延迟确认（500ms内二次判断）

### 7.3 电池消耗

**问题**：GPS持续定位耗电快

**解决方案**：
- 动态采样频率
- 暂停时停止定位
- 优化算法减少计算

---

## 八、扩展方向

### 8.1 可选功能
- 社交功能（骑行排行榜）
- 路线推荐
- 天气集成
- 卡路里计算优化

### 8.2 技术升级
- TypeScript重构
- 云存储同步（可选后端）
- 机器学习优化检测算法
- AR导航
