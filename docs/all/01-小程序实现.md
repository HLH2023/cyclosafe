# CycloSafe 小程序实现详解

本文档详细介绍 CycloSafe 微信小程序的技术实现，包括页面、组件、服务层、数据层和工具层的完整说明。

---

## 目录

- [技术栈](#技术栈)
- [项目结构](#项目结构)
- [页面实现](#页面实现)
- [组件库](#组件库)
- [服务层](#服务层)
- [数据层](#数据层)
- [工具层](#工具层)
- [状态管理](#状态管理)
- [性能优化](#性能优化)

---

## 技术栈

### 核心框架

| 技术 | 版本 | 用途 |
|------|------|------|
| uni-app | latest | 跨平台开发框架 |
| Vue 3 | latest | 前端框架（Composition API） |
| SCSS | latest | CSS 预处理器 |

### UI 和工具库

| 库名 | 版本 | 用途 |
|------|------|------|
| @dcloudio/uni-ui | ^1.5.11 | 官方 UI 组件库 |
| Pinia | ^3.0.3 | 状态管理 |
| @qiun/ucharts | ^2.5.0 | 轻量级图表 |
| echarts | ^5.4.3 | 数据可视化 |
| dayjs | ^1.11.18 | 日期处理 |

### 微信 API

- **wx.setStorage** - 本地存储（10MB限制）
- **wx.getLocation** - GPS定位（GCJ-02坐标）
- **wx.startLocationUpdate** - 持续定位
- **wx.onAccelerometerChange** - 加速度计监听
- **wx.onGyroscopeChange** - 陀螺仪监听
- **wx.makePhoneCall** - 拨打电话
- **wx.vibrateShort/Long** - 震动反馈

---

## 项目结构

```
mobileHomework/
├── pages/                      # 页面
│   ├── index/                 # 主页
│   ├── riding/                # 骑行页（核心）
│   ├── analysis/              # 数据分析
│   ├── history/               # 历史记录
│   ├── settings/              # 设置
│   ├── danger-points/         # 危险点管理
│   ├── emergency-contacts/    # 紧急联系人
│   └── simulate/              # 模拟测试
│
├── components/                # 组件
│   ├── glass-card/           # 玻璃态卡片
│   ├── line-chart/           # 折线图
│   ├── m-icon/               # Material 图标
│   ├── ride-card/            # 骑行记录卡片
│   ├── stat-card/            # 统计卡片
│   └── tab-bar/              # 底部导航
│
├── services/                  # 业务逻辑层
│   └── sensorService.js      # 传感器服务
│
├── db/                       # 数据访问层
│   ├── database.js           # 数据库初始化
│   └── repositories/         # 仓储模式
│       ├── RidingRecordRepository.js
│       ├── DangerPointRepository.js
│       └── SettingsRepository.js
│
├── utils/                    # 工具层
│   ├── gpsCalculator.js     # GPS计算
│   ├── storage-engine.js    # 存储引擎
│   ├── mlModel.js           # ML模型
│   ├── dataCollector.js     # 数据收集
│   ├── formatter.js         # 格式化
│   ├── emergencyHelper.js   # 紧急求助
│   ├── vibrationHelper.js   # 震动控制
│   └── constants.js         # 常量
│
├── store/                    # 状态管理
│   ├── theme.js             # 主题
│   ├── mapSettings.js       # 地图设置
│   └── units.js             # 单位设置
│
├── composables/              # 组合式函数
│   └── useUnits.js          # 单位转换
│
├── config/                   # 配置
│   └── map.config.js        # 地图配置
│
├── App.vue                   # 应用入口
├── main.js                   # 主配置
├── pages.json                # 页面路由
└── manifest.json             # 应用清单
```

---

## 页面实现

### 1. 主页 (index.vue)

**功能**：数据概览、快速开始骑行

**核心实现**：

```vue
<script setup>
import { ref, computed, onMounted } from 'vue';
import { getRidingRecordRepository } from '@/db/repositories/index.js';

const stats = ref({
  totalDistance: 0,    // 总距离
  totalDuration: 0,    // 总时长
  totalRides: 0,       // 总次数
  avgSpeed: 0          // 平均速度
});

onMounted(async () => {
  await loadStats();
});

async function loadStats() {
  const repo = getRidingRecordRepository();
  const records = await repo.findAll();

  stats.value = {
    totalDistance: records.reduce((sum, r) => sum + r.distance, 0),
    totalDuration: records.reduce((sum, r) => sum + r.duration, 0),
    totalRides: records.length,
    avgSpeed: records.reduce((sum, r) => sum + r.avg_speed, 0) / records.length
  };
}
</script>
```

**关键特性**：
- 统计卡片展示（总距离、总时长、总骑行次数）
- 最近骑行记录列表
- 一键开始骑行按钮
- 深色/浅色主题切换

**文件位置**：`pages/index/index.vue`

---

### 2. 骑行页 (riding.vue) ⭐核心页面

**功能**：实时骑行监测、GPS追踪、安全检测

#### 2.1 页面结构

```vue
<template>
  <view class="riding-page">
    <!-- 顶部状态栏 -->
    <view class="header">
      <text>{{ ridingStatusText }}</text>
      <text>{{ currentTime }}</text>
    </view>

    <!-- 地图展示 -->
    <map
      :longitude="currentLocation.longitude"
      :latitude="currentLocation.latitude"
      :markers="markers"
      :polyline="polyline"
      show-location
    />

    <!-- 数据卡片 -->
    <view class="data-card">
      <text class="speed-value">{{ currentSpeed.toFixed(1) }}</text>
      <text class="speed-unit">KM/H</text>
    </view>

    <!-- 控制按钮 -->
    <view class="control-section">
      <view @click="startRiding" v-if="!isRiding">开始</view>
      <view @click="pauseRiding" v-if="isRiding && !isPaused">暂停</view>
      <view @click="stopRiding" v-if="isRiding">结束</view>
    </view>
  </view>
</template>
```

#### 2.2 核心状态管理

```javascript
// 骑行状态
const isRiding = ref(false);
const isPaused = ref(false);
const currentSpeed = ref(0);
const distance = ref(0);
const duration = ref(0);

// GPS 数据
const currentLocation = ref({
  longitude: 0,
  latitude: 0
});
const trackPoints = ref([]);  // 轨迹点数组

// 地图数据
const markers = ref([]);      // 标记点（起点、终点、危险点）
const polyline = ref([]);     // 轨迹线
```

#### 2.3 开始骑行流程

```javascript
async function startRiding() {
  try {
    // 1. 请求定位权限
    const authResult = await uni.authorize({
      scope: 'scope.userLocation'
    });

    // 2. 获取初始位置
    const location = await uni.getLocation({
      type: 'gcj02',
      altitude: true
    });

    currentLocation.value = {
      longitude: location.longitude,
      latitude: location.latitude
    };

    // 3. 启动持续定位
    uni.startLocationUpdate();
    uni.onLocationChange(onLocationChange);

    // 4. 启动传感器监听
    sensorService.start({
      sensitivity: currentSensitivity.value,
      fallDetectionEnabled: true
    });

    // 5. 设置传感器回调
    sensorService.onFallDetected(handleFallDetected);
    sensorService.onHardBrakeDetected(handleHardBrake);

    // 6. 更新状态
    isRiding.value = true;
    startTime.value = Date.now();
    currentRecordId.value = generateUUID();

    // 7. 启动计时器
    startTimer();

    uni.showToast({ title: '开始骑行', icon: 'success' });
  } catch (error) {
    console.error('启动骑行失败:', error);
    uni.showToast({ title: '启动失败', icon: 'error' });
  }
}
```

#### 2.4 GPS 位置更新

```javascript
function onLocationChange(location) {
  const newPoint = {
    latitude: location.latitude,
    longitude: location.longitude,
    altitude: location.altitude || 0,
    speed: location.speed || 0,
    accuracy: location.accuracy || 0,
    timestamp: Date.now()
  };

  // 更新当前位置
  currentLocation.value = {
    longitude: newPoint.longitude,
    latitude: newPoint.latitude
  };

  // 判断是否需要记录轨迹点
  const lastPoint = trackPoints.value[trackPoints.value.length - 1];
  if (shouldRecordPoint(newPoint, lastPoint)) {
    // 计算距离增量
    if (lastPoint) {
      const dist = calculateDistance(
        lastPoint.latitude, lastPoint.longitude,
        newPoint.latitude, newPoint.longitude
      );
      distance.value += dist;
    }

    // 记录轨迹点
    trackPoints.value.push(newPoint);

    // 更新地图轨迹线
    updatePolyline();

    // 更新速度
    currentSpeed.value = newPoint.speed * 3.6; // m/s -> km/h
    sensorService.updateSpeed(currentSpeed.value);

    // 更新最高速度
    if (currentSpeed.value > maxSpeed.value) {
      maxSpeed.value = currentSpeed.value;
    }
  }
}
```

#### 2.5 摔倒检测处理

```javascript
async function handleFallDetected(data) {
  console.log('检测到摔倒:', data);

  // 1. 震动反馈
  vibrateLong();

  // 2. 显示倒计时弹窗（10秒内可取消）
  const confirmed = await showEmergencyCountdown({
    type: 'fall',
    duration: 10000,
    onCancel: () => {
      console.log('用户取消了紧急求助');
    }
  });

  if (confirmed) {
    // 3. 保存危险点
    const dangerPointRepo = getDangerPointRepository();
    await dangerPointRepo.create({
      type: 'fall',
      latitude: currentLocation.value.latitude,
      longitude: currentLocation.value.longitude,
      timestamp: Date.now(),
      sensor_data: data,
      record_id: currentRecordId.value
    });

    // 4. 触发紧急求助
    triggerEmergencyCall();

    // 5. 在地图上标记
    markers.value.push({
      id: Date.now(),
      latitude: currentLocation.value.latitude,
      longitude: currentLocation.value.longitude,
      iconPath: '/static/icons/fall-marker.png',
      width: 32,
      height: 32
    });
  }
}
```

#### 2.6 结束骑行

```javascript
async function stopRiding() {
  try {
    // 1. 停止定位
    uni.stopLocationUpdate();

    // 2. 停止传感器
    sensorService.stop();

    // 3. 停止计时器
    clearInterval(timerInterval.value);

    // 4. 计算统计数据
    const endTime = Date.now();
    const totalDuration = endTime - startTime.value;
    const avgSpeed = distance.value / (totalDuration / 3600000); // km/h

    // 5. 保存骑行记录
    const repo = getRidingRecordRepository();
    const saved = repo.saveRecord({
      id: currentRecordId.value,
      startTime: startTime.value,
      endTime: endTime,
      duration: totalDuration,
      distance: distance.value,
      avgSpeed: avgSpeed,
      maxSpeed: maxSpeed.value,
      totalAscent: totalAscent.value,
      trackPoints: trackPoints.value
    });

    if (saved) {
      uni.showToast({ title: '骑行记录已保存', icon: 'success' });

      // 6. 跳转到记录详情页
      setTimeout(() => {
        uni.navigateTo({
          url: `/pages/history/history?recordId=${currentRecordId.value}`
        });
      }, 1500);
    }

    // 7. 重置状态
    resetState();
  } catch (error) {
    console.error('结束骑行失败:', error);
  }
}
```

#### 2.7 数据收集（ML训练）

```javascript
// 数据收集开关
const isDataCollectionEnabled = ref(false);
const dataCollector = new DataCollector();

function toggleDataCollection() {
  isDataCollectionEnabled.value = !isDataCollectionEnabled.value;

  if (isDataCollectionEnabled.value) {
    // 开始收集
    dataCollector.startCollecting({
      onDataPoint: (data) => {
        console.log('收集数据点:', data);
      }
    });

    // 监听传感器数据
    sensorService.onSensorData((acc, gyro) => {
      dataCollector.addDataPoint({
        timestamp: Date.now(),
        acc: acc,
        gyro: gyro,
        speed: currentSpeed.value
      });
    });
  } else {
    // 停止收集并上传
    const collectedData = dataCollector.stopCollecting();
    uploadTrainingData(collectedData);
  }
}
```

**文件位置**：`pages/riding/riding.vue`

---

### 3. 历史记录页 (history.vue)

**功能**：查看历史骑行记录、轨迹回放

#### 核心实现

```javascript
const records = ref([]);
const selectedRecord = ref(null);

async function loadRecords() {
  const repo = getRidingRecordRepository();
  const allRecords = await repo.findAll();

  // 按时间倒序排列
  records.value = allRecords.sort((a, b) =>
    b.start_time - a.start_time
  );
}

async function viewRecord(record) {
  // 加载轨迹点
  const trackPoints = await repo.getTrackPoints(record.id);

  selectedRecord.value = {
    ...record,
    trackPoints: trackPoints
  };

  // 在地图上展示轨迹
  showTrackOnMap(trackPoints);
}

async function deleteRecord(recordId) {
  const confirmed = await uni.showModal({
    title: '确认删除',
    content: '删除后无法恢复，是否继续？'
  });

  if (confirmed) {
    const repo = getRidingRecordRepository();
    repo.deleteById(recordId);
    loadRecords();
  }
}
```

**功能特性**：
- 记录列表（分页加载）
- 记录详情（轨迹回放）
- 速度分段着色（绿色<15km/h，蓝色<25km/h，红色≥25km/h）
- 危险点标记
- 记录删除

**文件位置**：`pages/history/history.vue`

---

### 4. 数据分析页 (analysis.vue)

**功能**：统计分析、趋势图表

#### 数据聚合

```javascript
const analysisData = ref({
  totalStats: {
    distance: 0,
    duration: 0,
    rides: 0,
    avgSpeed: 0
  },
  weeklyData: [],   // 周数据
  monthlyData: [],  // 月数据
  speedDistribution: [] // 速度分布
});

async function loadAnalysisData() {
  const repo = getRidingRecordRepository();
  const records = await repo.findAll();

  // 总统计
  analysisData.value.totalStats = {
    distance: records.reduce((sum, r) => sum + r.distance, 0),
    duration: records.reduce((sum, r) => sum + r.duration, 0),
    rides: records.length,
    avgSpeed: records.reduce((sum, r) => sum + r.avg_speed, 0) / records.length
  };

  // 周数据（最近7天）
  const weeklyData = aggregateByWeek(records);
  analysisData.value.weeklyData = weeklyData;

  // 速度分布
  analysisData.value.speedDistribution = calculateSpeedDistribution(records);
}

function aggregateByWeek(records) {
  const weekData = Array(7).fill(0).map((_, i) => ({
    day: dayjs().subtract(6 - i, 'day').format('MM/DD'),
    distance: 0,
    duration: 0
  }));

  records.forEach(record => {
    const recordDate = dayjs(record.start_time);
    const daysAgo = dayjs().diff(recordDate, 'day');

    if (daysAgo >= 0 && daysAgo < 7) {
      const index = 6 - daysAgo;
      weekData[index].distance += record.distance;
      weekData[index].duration += record.duration;
    }
  });

  return weekData;
}
```

#### 图表渲染

```vue
<template>
  <line-chart
    :data="chartData"
    :options="chartOptions"
  />
</template>

<script setup>
const chartData = computed(() => ({
  labels: analysisData.value.weeklyData.map(d => d.day),
  datasets: [{
    label: '距离 (km)',
    data: analysisData.value.weeklyData.map(d => d.distance),
    color: '#007AFF'
  }]
}));
</script>
```

**文件位置**：`pages/analysis/analysis.vue`

---

### 5. 设置页 (settings.vue)

**功能**：应用设置、检测灵敏度调整

**核心设置**：

```javascript
const settings = ref({
  // 检测设置
  sensitivity: 'medium',           // 灵敏度：low/medium/high
  fallDetectionEnabled: true,      // 摔倒检测开关
  hardBrakeDetectionEnabled: true, // 急刹车检测开关

  // 单位设置
  distanceUnit: 'km',              // km/mi
  speedUnit: 'km/h',               // km/h/mph

  // 地图设置
  mapType: 'standard',             // standard/satellite

  // 主题
  theme: 'auto'                    // light/dark/auto
});

async function saveSetting(key, value) {
  const repo = getSettingsRepository();
  await repo.set(key, value);

  // 应用设置
  applySettings();
}

function applySettings() {
  // 应用检测灵敏度
  sensorService.setSensitivity(settings.value.sensitivity);

  // 应用主题
  if (settings.value.theme === 'dark') {
    themeStore.setDark(true);
  } else if (settings.value.theme === 'light') {
    themeStore.setDark(false);
  }
}
```

**文件位置**：`pages/settings/settings.vue`

---

### 6. 紧急联系人页 (emergency-contacts.vue)

**功能**：管理紧急联系人（最多3个）

**数据结构**：

```javascript
const contacts = ref([
  {
    id: '1',
    name: '张三',
    phone: '138****8888',
    relationship: '家人'
  }
]);

async function addContact(contact) {
  if (contacts.value.length >= 3) {
    uni.showToast({ title: '最多添加3个联系人', icon: 'none' });
    return;
  }

  const repo = getSettingsRepository();
  contacts.value.push({
    id: generateUUID(),
    ...contact
  });

  await repo.set('emergency_contacts', contacts.value);
}

async function makeEmergencyCall() {
  if (contacts.value.length === 0) {
    uni.showToast({ title: '请先添加紧急联系人', icon: 'none' });
    return;
  }

  // 拨打第一个联系人
  uni.makePhoneCall({
    phoneNumber: contacts.value[0].phone
  });
}
```

**文件位置**：`pages/emergency-contacts/emergency-contacts.vue`

---

### 7. 危险点管理页 (danger-points.vue)

**功能**：查看和管理检测到的危险点

```javascript
const dangerPoints = ref([]);

async function loadDangerPoints() {
  const repo = getDangerPointRepository();
  dangerPoints.value = await repo.findAll();
}

async function deleteDangerPoint(id) {
  const repo = getDangerPointRepository();
  await repo.deleteById(id);
  loadDangerPoints();
}

function showOnMap(point) {
  // 在地图上显示危险点位置
  uni.navigateTo({
    url: `/pages/riding/riding?latitude=${point.latitude}&longitude=${point.longitude}`
  });
}
```

**文件位置**：`pages/danger-points/danger-points.vue`

---

### 8. 模拟测试页 (simulate.vue)

**功能**：模拟传感器数据、标注训练数据

```javascript
const simulatedData = ref([]);
const isSimulating = ref(false);
const currentLabel = ref('normal'); // 'normal' or 'fall'

function startSimulation() {
  isSimulating.value = true;

  // 启动传感器监听
  sensorService.start({ sensitivity: 'high' });

  // 收集数据
  sensorService.onSensorData((acc, gyro) => {
    simulatedData.value.push({
      timestamp: Date.now(),
      acc: acc,
      gyro: gyro,
      label: currentLabel.value
    });
  });
}

async function uploadSimulatedData() {
  const dataCollector = new DataCollector();

  const result = await dataCollector.uploadToServer({
    user_id: 'user_' + Date.now(),
    label: currentLabel.value,
    source: 'simulate',
    duration: simulatedData.value.length * 20, // 20ms per sample
    samples: simulatedData.value
  });

  if (result.success) {
    uni.showToast({ title: '上传成功', icon: 'success' });
    simulatedData.value = [];
  }
}
```

**文件位置**：`pages/simulate/simulate.vue`

---

## 组件库

### 1. glass-card（玻璃态卡片）

**用途**：毛玻璃效果卡片容器

```vue
<template>
  <view class="glass-card" :style="cardStyle">
    <slot></slot>
  </view>
</template>

<style lang="scss">
.glass-card {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}
</style>
```

**文件位置**：`components/glass-card/glass-card.vue`

---

### 2. line-chart（折线图）

**用途**：数据趋势可视化

```vue
<template>
  <view class="chart-container">
    <qiun-ucharts
      type="line"
      :opts="opts"
      :chartData="chartData"
    />
  </view>
</template>

<script setup>
const props = defineProps({
  data: Object,
  options: Object
});

const chartData = computed(() => ({
  categories: props.data.labels,
  series: [{
    name: props.data.datasets[0].label,
    data: props.data.datasets[0].data
  }]
}));
</script>
```

**文件位置**：`components/line-chart/line-chart.vue`

---

### 3. m-icon（Material 图标）

**用途**：Material Design 图标组件

```vue
<template>
  <text class="material-icons" :style="iconStyle">{{ name }}</text>
</template>

<script setup>
const props = defineProps({
  name: String,
  size: { type: Number, default: 24 },
  color: { type: String, default: '#000000' }
});

const iconStyle = computed(() => ({
  fontSize: `${props.size}px`,
  color: props.color
}));
</script>
```

**文件位置**：`components/m-icon/m-icon.vue`

---

### 4. ride-card（骑行记录卡片）

**用途**：展示单条骑行记录

```vue
<template>
  <view class="ride-card" @click="handleClick">
    <view class="card-header">
      <text class="date">{{ formattedDate }}</text>
      <text class="duration">{{ formattedDuration }}</text>
    </view>
    <view class="card-body">
      <view class="stat">
        <text class="value">{{ record.distance.toFixed(2) }}</text>
        <text class="label">km</text>
      </view>
      <view class="stat">
        <text class="value">{{ record.avg_speed.toFixed(1) }}</text>
        <text class="label">km/h</text>
      </view>
    </view>
  </view>
</template>

<script setup>
import dayjs from 'dayjs';

const props = defineProps({
  record: Object
});

const emit = defineEmits(['click']);

const formattedDate = computed(() =>
  dayjs(props.record.start_time).format('YYYY-MM-DD HH:mm')
);

const formattedDuration = computed(() => {
  const hours = Math.floor(props.record.duration / 3600000);
  const minutes = Math.floor((props.record.duration % 3600000) / 60000);
  return `${hours}:${String(minutes).padStart(2, '0')}`;
});
</script>
```

**文件位置**：`components/ride-card/ride-card.vue`

---

### 5. stat-card（统计卡片）

**用途**：展示统计数据

```vue
<template>
  <view class="stat-card">
    <m-icon :name="icon" :size="32" :color="iconColor" />
    <view class="stat-content">
      <text class="stat-value">{{ value }}</text>
      <text class="stat-label">{{ label }}</text>
    </view>
  </view>
</template>
```

**文件位置**：`components/stat-card/stat-card.vue`

---

### 6. tab-bar（底部导航）

**用途**：自定义底部导航栏

```vue
<template>
  <view class="tab-bar">
    <view
      v-for="tab in tabs"
      :key="tab.path"
      class="tab-item"
      :class="{ active: currentPath === tab.path }"
      @click="switchTab(tab.path)"
    >
      <m-icon :name="tab.icon" :size="24" />
      <text>{{ tab.text }}</text>
    </view>
  </view>
</template>

<script setup>
const tabs = [
  { path: '/pages/index/index', icon: 'home', text: '主页' },
  { path: '/pages/riding/riding', icon: 'directions_bike', text: '骑行' },
  { path: '/pages/analysis/analysis', icon: 'analytics', text: '分析' },
  { path: '/pages/settings/settings', icon: 'settings', text: '设置' }
];

function switchTab(path) {
  uni.switchTab({ url: path });
}
</script>
```

**文件位置**：`components/tab-bar/tab-bar.vue`

---

## 服务层

### sensorService.js（传感器服务）⭐核心模块

**职责**：封装传感器监听、数据滤波、摔倒检测

#### 类结构

```
sensorService
├── MovingAverageFilter（移动平均滤波器）
├── FallDetector（摔倒检测器）
└── API
    ├── start()              # 启动传感器
    ├── stop()               # 停止传感器
    ├── setSensitivity()     # 设置灵敏度
    ├── updateSpeed()        # 更新速度
    ├── onFallDetected()     # 摔倒回调
    ├── onHardBrakeDetected()# 急刹车回调
    └── onSensorData()       # 原始数据回调
```

#### MovingAverageFilter（移动平均滤波器）

```javascript
class MovingAverageFilter {
  constructor(windowSize = 5) {
    this.bufferX = [];
    this.bufferY = [];
    this.bufferZ = [];
    this.windowSize = windowSize;
  }

  filter(x, y, z) {
    // 添加新数据
    this.bufferX.push(x);
    this.bufferY.push(y);
    this.bufferZ.push(z);

    // 移除旧数据
    if (this.bufferX.length > this.windowSize) {
      this.bufferX.shift();
      this.bufferY.shift();
      this.bufferZ.shift();
    }

    // 返回平均值
    return {
      x: this.average(this.bufferX),
      y: this.average(this.bufferY),
      z: this.average(this.bufferZ)
    };
  }

  average(arr) {
    return arr.reduce((a, b) => a + b, 0) / arr.length;
  }
}
```

#### FallDetector（摔倒检测器）

**检测阈值配置**：

```javascript
const thresholds = {
  low: {
    acceleration: 15,        // 15 m/s²
    gyroscope: 100,          // 100°/s
    speedDrop: 5,            // 5 km/h
    brakeAcceleration: 12,
    brakeGyroscope: 80,
    brakeSpeedDrop: 10,
    brakeDeceleration: -2.0
  },
  medium: {
    acceleration: 10,        // 10 m/s²
    gyroscope: 50,           // 50°/s
    speedDrop: 5,
    brakeAcceleration: 8,
    brakeGyroscope: 60,
    brakeSpeedDrop: 8,
    brakeDeceleration: -1.5
  },
  high: {
    acceleration: 6,         // 6 m/s²
    gyroscope: 8,            // 8°/s
    speedDrop: 4,
    brakeAcceleration: 5,
    brakeGyroscope: 40,
    brakeSpeedDrop: 6,
    brakeDeceleration: -1.2
  }
};
```

**摔倒检测逻辑**：

```javascript
detect(acc, gyro, speed) {
  // 1. 更新传感器数据
  this.updateAccelerometer(acc);
  this.updateGyroscope(gyro);
  this.updateSpeed(speed);

  // 2. 检查冷却时间
  const now = Date.now();
  if (now - this.lastDetectionTime < this.detectionCooldown) {
    return null;
  }

  // 3. 计算加速度模和角速度模
  const accMag = Math.sqrt(
    this.accelerometerData.x ** 2 +
    this.accelerometerData.y ** 2 +
    this.accelerometerData.z ** 2
  );

  const gyroMag = Math.sqrt(
    this.gyroscopeData.x ** 2 +
    this.gyroscopeData.y ** 2 +
    this.gyroscopeData.z ** 2
  );

  // 4. 摔倒检测
  if (this.detectFall(accMag, gyroMag)) {
    this.lastDetectionTime = now;
    return {
      type: 'fall',
      timestamp: now,
      acc: this.accelerometerData,
      gyro: this.gyroscopeData,
      speed: speed
    };
  }

  // 5. 急刹车检测
  if (this.detectHardBrake(accMag, gyroMag)) {
    this.lastDetectionTime = now;
    return {
      type: 'hard_brake',
      timestamp: now,
      acc: this.accelerometerData,
      gyro: this.gyroscopeData,
      speed: speed
    };
  }

  return null;
}

detectFall(accMag, gyroMag) {
  const { acceleration, gyroscope } = this.thresholds;

  // 条件1：加速度超过阈值
  const highAcceleration = accMag > acceleration;

  // 条件2：角速度超过阈值（高旋转）
  const highRotation = gyroMag > gyroscope;

  // 条件3：碰撞特征检测
  const hasImpact = this.detectImpact();

  // 条件4：速度骤降
  const speedDrop = this.detectSpeedDrop();

  return highAcceleration && highRotation && hasImpact && speedDrop;
}

detectHardBrake(accMag, gyroMag) {
  const {
    brakeAcceleration,
    brakeGyroscope,
    brakeSpeedDrop,
    brakeDeceleration,
    minSpeedForBrake
  } = this.thresholds;

  // 条件1：加速度超过阈值
  const highAcceleration = accMag > brakeAcceleration;

  // 条件2：角速度较低（低旋转，不是摔倒）
  const lowRotation = gyroMag < brakeGyroscope;

  // 条件3：速度足够高
  const currentSpeed = this.getCurrentSpeed();
  const speedEnough = currentSpeed > minSpeedForBrake;

  // 条件4：速度急降
  const speedDrop = this.detectSpeedDrop() > brakeSpeedDrop;

  // 条件5：减速度检测
  const deceleration = this.calculateDeceleration();
  const hardDeceleration = deceleration < brakeDeceleration;

  return highAcceleration && lowRotation && speedEnough &&
         speedDrop && hardDeceleration;
}
```

**碰撞特征检测**：

```javascript
detectImpact() {
  if (this.accHistory.length < 3) return false;

  // 检测加速度突变
  const recent = this.accHistory.slice(-3);
  const avgBefore = recent[0];
  const peak = recent[1];
  const avgAfter = recent[2];

  const magBefore = this.magnitude(avgBefore);
  const magPeak = this.magnitude(peak);
  const magAfter = this.magnitude(avgAfter);

  // 碰撞特征：先上升后下降
  const riseRatio = magPeak / magBefore;
  const fallRatio = magAfter / magPeak;

  return riseRatio > 1.5 && fallRatio < 0.7;
}
```

**速度骤降检测**：

```javascript
detectSpeedDrop() {
  if (this.speedHistory.length < 2) return 0;

  const recent = this.speedHistory.slice(-2);
  const speedDrop = recent[0].speed - recent[1].speed;

  return speedDrop; // km/h
}
```

#### API 使用示例

```javascript
import sensorService from '@/services/sensorService.js';

// 1. 启动传感器
sensorService.start({
  sensitivity: 'medium',        // 灵敏度
  fallDetectionEnabled: true    // 启用摔倒检测
});

// 2. 设置回调
sensorService.onFallDetected((data) => {
  console.log('摔倒检测:', data);
  // 触发告警
});

sensorService.onHardBrakeDetected((data) => {
  console.log('急刹车检测:', data);
});

sensorService.onSensorData((acc, gyro) => {
  console.log('原始传感器数据:', acc, gyro);
});

// 3. 更新GPS速度
sensorService.updateSpeed(currentSpeed);

// 4. 调整灵敏度
sensorService.setSensitivity('high');

// 5. 停止传感器
sensorService.stop();
```

**文件位置**：`services/sensorService.js`

---

## 数据层

### 存储架构

#### storage-engine.js（存储引擎）

**集合定义**：

```javascript
export const COLLECTIONS = {
  RIDING_RECORDS: 'riding_records',    // 骑行记录
  TRACK_POINTS: 'track_points',        // 轨迹点
  DANGER_POINTS: 'danger_points',      // 危险点
  SETTINGS: 'settings',                // 设置
  INDEXES: 'indexes'                   // 索引
};
```

**基础 API**：

```javascript
class StorageEngine {
  // 同步读取
  static get(key) {
    return wx.getStorageSync(key);
  }

  // 同步写入
  static set(key, value) {
    wx.setStorageSync(key, value);
  }

  // 异步读取
  static async getAsync(key) {
    return new Promise((resolve, reject) => {
      wx.getStorage({
        key: key,
        success: (res) => resolve(res.data),
        fail: reject
      });
    });
  }

  // 异步写入
  static async setAsync(key, value) {
    return new Promise((resolve, reject) => {
      wx.setStorage({
        key: key,
        data: value,
        success: resolve,
        fail: reject
      });
    });
  }

  // 删除
  static remove(key) {
    wx.removeStorageSync(key);
  }

  // 清空
  static clear() {
    wx.clearStorageSync();
  }

  // 获取存储信息
  static getInfo() {
    return wx.getStorageInfoSync();
  }
}
```

**文件位置**：`utils/storage-engine.js`

---

### Repository 模式

#### RidingRecordRepository（骑行记录仓储）

**数据模型**：

```javascript
// 骑行记录
{
  id: string,
  start_time: number,
  end_time: number,
  duration: number,        // 毫秒
  distance: number,        // 公里
  avg_speed: number,       // km/h
  max_speed: number,       // km/h
  total_ascent: number,    // 米
  created_at: number,
  updated_at: number
}

// 轨迹点
{
  latitude: number,
  longitude: number,
  altitude: number,        // 米
  speed: number,           // km/h
  timestamp: number,
  sequence: number         // 序列号
}
```

**主要方法**：

```javascript
class RidingRecordRepository {
  // 保存记录（含轨迹点）
  saveRecord(record) {
    const ridingRecords = wx.getStorageSync(COLLECTIONS.RIDING_RECORDS) || {};
    const trackPointsStorage = wx.getStorageSync(COLLECTIONS.TRACK_POINTS) || {};

    // 保存记录
    ridingRecords[record.id] = {
      id: record.id,
      start_time: record.startTime,
      end_time: record.endTime,
      duration: record.duration,
      distance: record.distance,
      avg_speed: record.avgSpeed,
      max_speed: record.maxSpeed,
      total_ascent: record.totalAscent || 0,
      created_at: Date.now(),
      updated_at: Date.now()
    };
    wx.setStorageSync(COLLECTIONS.RIDING_RECORDS, ridingRecords);

    // 保存轨迹点
    if (record.trackPoints && record.trackPoints.length > 0) {
      trackPointsStorage[record.id] = record.trackPoints;
      wx.setStorageSync(COLLECTIONS.TRACK_POINTS, trackPointsStorage);
    }

    // 更新索引
    this.updateIndex(record.id, record.startTime);

    return true;
  }

  // 查询所有记录
  findAll() {
    const ridingRecords = wx.getStorageSync(COLLECTIONS.RIDING_RECORDS) || {};
    return Object.values(ridingRecords);
  }

  // 根据ID查询
  findById(id) {
    const ridingRecords = wx.getStorageSync(COLLECTIONS.RIDING_RECORDS) || {};
    return ridingRecords[id] || null;
  }

  // 获取轨迹点
  getTrackPoints(recordId) {
    const trackPointsStorage = wx.getStorageSync(COLLECTIONS.TRACK_POINTS) || {};
    return trackPointsStorage[recordId] || [];
  }

  // 删除记录
  deleteById(id) {
    const ridingRecords = wx.getStorageSync(COLLECTIONS.RIDING_RECORDS) || {};
    const trackPointsStorage = wx.getStorageSync(COLLECTIONS.TRACK_POINTS) || {};

    delete ridingRecords[id];
    delete trackPointsStorage[id];

    wx.setStorageSync(COLLECTIONS.RIDING_RECORDS, ridingRecords);
    wx.setStorageSync(COLLECTIONS.TRACK_POINTS, trackPointsStorage);

    this.removeFromIndex(id);

    return true;
  }

  // 分页查询
  findByPage(page = 1, pageSize = 10) {
    const indexes = wx.getStorageSync(COLLECTIONS.INDEXES) || {};
    const recordIds = indexes.riding_records_by_time || [];

    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    const pageIds = recordIds.slice(start, end);

    const ridingRecords = wx.getStorageSync(COLLECTIONS.RIDING_RECORDS) || {};
    return pageIds.map(id => ridingRecords[id]).filter(Boolean);
  }
}
```

**索引管理**：

```javascript
// 更新时间索引
function updateIndex(id, startTime) {
  const indexes = wx.getStorageSync(COLLECTIONS.INDEXES) || {
    riding_records_by_time: [],
    danger_points_by_time: []
  };

  // 移除旧索引
  const oldIndex = indexes.riding_records_by_time.indexOf(id);
  if (oldIndex > -1) {
    indexes.riding_records_by_time.splice(oldIndex, 1);
  }

  // 插入新索引（保持倒序）
  const ridingRecords = wx.getStorageSync(COLLECTIONS.RIDING_RECORDS) || {};
  const insertIndex = indexes.riding_records_by_time.findIndex(existingId => {
    const existingRecord = ridingRecords[existingId];
    return startTime > (existingRecord?.start_time || 0);
  });

  if (insertIndex === -1) {
    indexes.riding_records_by_time.push(id);
  } else {
    indexes.riding_records_by_time.splice(insertIndex, 0, id);
  }

  wx.setStorageSync(COLLECTIONS.INDEXES, indexes);
}
```

**文件位置**：`db/repositories/RidingRecordRepository.js`

---

#### DangerPointRepository（危险点仓储）

**数据模型**：

```javascript
{
  id: string,
  type: 'fall' | 'hard_brake',
  timestamp: number,
  latitude: number,
  longitude: number,
  sensor_data: {
    acc: { x, y, z },
    gyro: { x, y, z },
    speed: number
  },
  record_id: string,      // 关联的骑行记录ID
  created_at: number
}
```

**主要方法**：

```javascript
class DangerPointRepository {
  create(dangerPoint) {
    const dangerPoints = wx.getStorageSync(COLLECTIONS.DANGER_POINTS) || {};

    dangerPoints[dangerPoint.id] = {
      ...dangerPoint,
      created_at: Date.now()
    };

    wx.setStorageSync(COLLECTIONS.DANGER_POINTS, dangerPoints);
    this.updateIndex(dangerPoint.id, dangerPoint.timestamp);

    return true;
  }

  findAll() {
    const dangerPoints = wx.getStorageSync(COLLECTIONS.DANGER_POINTS) || {};
    return Object.values(dangerPoints);
  }

  findByRecordId(recordId) {
    const dangerPoints = this.findAll();
    return dangerPoints.filter(dp => dp.record_id === recordId);
  }

  deleteById(id) {
    const dangerPoints = wx.getStorageSync(COLLECTIONS.DANGER_POINTS) || {};
    delete dangerPoints[id];
    wx.setStorageSync(COLLECTIONS.DANGER_POINTS, dangerPoints);
    this.removeFromIndex(id);
    return true;
  }
}
```

**文件位置**：`db/repositories/DangerPointRepository.js`

---

#### SettingsRepository（设置仓储）

**键值存储**：

```javascript
class SettingsRepository {
  get(key, defaultValue = null) {
    const settings = wx.getStorageSync(COLLECTIONS.SETTINGS) || {};
    return settings[key] !== undefined ? settings[key] : defaultValue;
  }

  set(key, value) {
    const settings = wx.getStorageSync(COLLECTIONS.SETTINGS) || {};
    settings[key] = value;
    wx.setStorageSync(COLLECTIONS.SETTINGS, settings);
    return true;
  }

  getAll() {
    return wx.getStorageSync(COLLECTIONS.SETTINGS) || {};
  }

  delete(key) {
    const settings = wx.getStorageSync(COLLECTIONS.SETTINGS) || {};
    delete settings[key];
    wx.setStorageSync(COLLECTIONS.SETTINGS, settings);
    return true;
  }
}
```

**常用设置键**：

```javascript
const SETTING_KEYS = {
  SENSITIVITY: 'sensitivity',                    // 检测灵敏度
  FALL_DETECTION_ENABLED: 'fallDetectionEnabled',
  DISTANCE_UNIT: 'distanceUnit',                 // 距离单位
  SPEED_UNIT: 'speedUnit',                       // 速度单位
  THEME: 'theme',                                // 主题
  EMERGENCY_CONTACTS: 'emergency_contacts',      // 紧急联系人
  MAP_TYPE: 'mapType'                            // 地图类型
};
```

**文件位置**：`db/repositories/SettingsRepository.js`

---

### 数据库初始化

**database.js**：

```javascript
import { COLLECTIONS } from '@/utils/storage-engine.js';

export function setupDatabase() {
  // 初始化集合
  const collections = [
    COLLECTIONS.RIDING_RECORDS,
    COLLECTIONS.TRACK_POINTS,
    COLLECTIONS.DANGER_POINTS,
    COLLECTIONS.SETTINGS,
    COLLECTIONS.INDEXES
  ];

  collections.forEach(collection => {
    const data = wx.getStorageSync(collection);
    if (!data) {
      if (collection === COLLECTIONS.INDEXES) {
        wx.setStorageSync(collection, {
          riding_records_by_time: [],
          danger_points_by_time: []
        });
      } else if (collection === COLLECTIONS.SETTINGS) {
        wx.setStorageSync(collection, {
          sensitivity: 'medium',
          fallDetectionEnabled: true,
          distanceUnit: 'km',
          speedUnit: 'km/h',
          theme: 'auto'
        });
      } else {
        wx.setStorageSync(collection, {});
      }
    }
  });

  console.log('数据库初始化完成');
}

// 获取仓储实例
export function getRidingRecordRepository() {
  return new RidingRecordRepository();
}

export function getDangerPointRepository() {
  return new DangerPointRepository();
}

export function getSettingsRepository() {
  return new SettingsRepository();
}
```

**在 App.vue 中初始化**：

```javascript
// App.vue
import { setupDatabase } from '@/db/database.js';

export default {
  onLaunch() {
    console.log('App Launch');

    // 初始化数据库
    setupDatabase();
  }
}
```

**文件位置**：`db/database.js`

---

## 工具层

### 1. gpsCalculator.js（GPS计算工具）

**Haversine 距离计算**：

```javascript
/**
 * 计算两点间距离（Haversine公式）
 * @param {number} lat1 纬度1
 * @param {number} lon1 经度1
 * @param {number} lat2 纬度2
 * @param {number} lon2 经度2
 * @returns {number} 距离（公里）
 */
export function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // 地球半径（公里）

  const dLat = toRadians(lat2 - lat1);
  const dLon = toRadians(lon2 - lon1);

  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}

function toRadians(degrees) {
  return degrees * Math.PI / 180;
}
```

**轨迹点过滤**：

```javascript
/**
 * 判断是否应该记录轨迹点
 * @param {Object} newPoint 新轨迹点
 * @param {Object} lastPoint 上一个轨迹点
 * @param {Object} options 配置选项
 * @returns {boolean}
 */
export function shouldRecordPoint(newPoint, lastPoint, options = {}) {
  const {
    minDistance = 5,       // 最小距离（米）
    minInterval = 3000,    // 最小时间间隔（毫秒）
    maxAccuracy = 50       // 最大精度（米）
  } = options;

  // 检查精度
  if (newPoint.accuracy > maxAccuracy) {
    return false;
  }

  // 第一个点直接记录
  if (!lastPoint) {
    return true;
  }

  // 检查时间间隔
  const timeDiff = newPoint.timestamp - lastPoint.timestamp;
  if (timeDiff < minInterval) {
    return false;
  }

  // 检查距离
  const distance = calculateDistance(
    lastPoint.latitude, lastPoint.longitude,
    newPoint.latitude, newPoint.longitude
  ) * 1000; // 转换为米

  return distance >= minDistance;
}
```

**海拔变化计算**：

```javascript
/**
 * 计算海拔变化
 * @param {Array} trackPoints 轨迹点数组
 * @returns {Object} { ascent: 爬升(m), descent: 下降(m) }
 */
export function calculateElevationChange(trackPoints) {
  let ascent = 0;
  let descent = 0;

  for (let i = 1; i < trackPoints.length; i++) {
    const diff = trackPoints[i].altitude - trackPoints[i - 1].altitude;

    if (diff > 0) {
      ascent += diff;
    } else {
      descent += Math.abs(diff);
    }
  }

  return { ascent, descent };
}
```

**速度着色**：

```javascript
/**
 * 根据速度返回颜色
 * @param {number} speed 速度（km/h）
 * @returns {string} 十六进制颜色
 */
export function getSpeedColor(speed) {
  if (speed < 15) {
    return '#00FF00';  // 绿色
  } else if (speed < 25) {
    return '#0000FF';  // 蓝色
  } else {
    return '#FF0000';  // 红色
  }
}
```

**文件位置**：`utils/gpsCalculator.js`

---

### 2. emergencyHelper.js（紧急求助工具）

**倒计时弹窗**：

```javascript
/**
 * 显示紧急求助倒计时
 * @param {Object} options 配置
 * @returns {Promise<boolean>} 是否确认求助
 */
export async function showEmergencyCountdown(options = {}) {
  const {
    type = 'fall',
    duration = 10000,
    onCancel = null
  } = options;

  const title = type === 'fall' ? '检测到摔倒' : '检测到急刹车';
  const content = `将在 ${duration / 1000} 秒后自动拨打紧急联系人`;

  return new Promise((resolve) => {
    let countdown = duration / 1000;
    let confirmed = false;

    // 显示模态框
    const modalId = uni.showModal({
      title: title,
      content: content,
      showCancel: true,
      cancelText: '我没事',
      confirmText: '立即求助',
      success: (res) => {
        if (res.confirm) {
          confirmed = true;
          resolve(true);
        } else {
          confirmed = false;
          if (onCancel) onCancel();
          resolve(false);
        }
      }
    });

    // 倒计时
    const timer = setInterval(() => {
      countdown--;

      if (countdown <= 0 || confirmed) {
        clearInterval(timer);
        if (!confirmed) {
          resolve(true);
        }
      }
    }, 1000);
  });
}
```

**拨打紧急电话**：

```javascript
/**
 * 拨打紧急联系人
 */
export async function callEmergencyContact() {
  const settingsRepo = getSettingsRepository();
  const contacts = settingsRepo.get('emergency_contacts', []);

  if (contacts.length === 0) {
    uni.showToast({ title: '未设置紧急联系人', icon: 'none' });
    return;
  }

  // 拨打第一个联系人
  const firstContact = contacts[0];

  uni.makePhoneCall({
    phoneNumber: firstContact.phone,
    success: () => {
      console.log('正在拨打:', firstContact.name);
    },
    fail: (error) => {
      console.error('拨打失败:', error);
    }
  });
}
```

**文件位置**：`utils/emergencyHelper.js`

---

### 3. vibrationHelper.js（震动控制）

```javascript
/**
 * 短震动（15ms）
 */
export function vibrateShort() {
  uni.vibrateShort({
    type: 'light',
    success: () => console.log('短震动'),
    fail: (error) => console.error('震动失败:', error)
  });
}

/**
 * 长震动（400ms）
 */
export function vibrateLong() {
  uni.vibrateLong({
    success: () => console.log('长震动'),
    fail: (error) => console.error('震动失败:', error)
  });
}

/**
 * 自定义震动模式
 * @param {Array} pattern 震动模式 [震动时长, 停顿时长, ...]
 */
export function vibratePattern(pattern = [100, 50, 100]) {
  let index = 0;

  function vibrate() {
    if (index >= pattern.length) return;

    const duration = pattern[index];
    if (index % 2 === 0) {
      // 震动
      uni.vibrateLong();
      setTimeout(() => {
        index++;
        vibrate();
      }, duration);
    } else {
      // 停顿
      setTimeout(() => {
        index++;
        vibrate();
      }, duration);
    }
  }

  vibrate();
}
```

**文件位置**：`utils/vibrationHelper.js`

---

### 4. dataCollector.js（数据收集工具）

**数据收集器**：

```javascript
class DataCollector {
  constructor() {
    this.data = [];
    this.isCollecting = false;
  }

  startCollecting(options = {}) {
    this.isCollecting = true;
    this.data = [];
    this.options = options;
    console.log('开始收集数据');
  }

  addDataPoint(dataPoint) {
    if (!this.isCollecting) return;

    this.data.push(dataPoint);

    if (this.options.onDataPoint) {
      this.options.onDataPoint(dataPoint);
    }
  }

  stopCollecting() {
    this.isCollecting = false;
    console.log('停止收集，共', this.data.length, '个数据点');
    return this.data;
  }

  async uploadToServer(metadata) {
    const url = 'https://your-api.com/api/upload/training-data';

    try {
      const response = await uni.request({
        url: url,
        method: 'POST',
        data: {
          user_id: metadata.user_id,
          label: metadata.label,
          source: metadata.source,
          duration: metadata.duration,
          samples: this.data.map(d => ({
            timestamp: d.timestamp,
            acc: d.acc,
            gyro: d.gyro
          }))
        }
      });

      console.log('上传成功:', response.data);
      return response.data;
    } catch (error) {
      console.error('上传失败:', error);
      throw error;
    }
  }
}

export default DataCollector;
```

**文件位置**：`utils/dataCollector.js`

---

### 5. formatter.js（格式化工具）

```javascript
/**
 * 格式化时长
 * @param {number} ms 毫秒
 * @returns {string} HH:MM:SS
 */
export function formatDuration(ms) {
  const seconds = Math.floor(ms / 1000);
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;

  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
}

/**
 * 格式化距离
 * @param {number} km 公里
 * @returns {string}
 */
export function formatDistance(km) {
  if (km < 1) {
    return `${(km * 1000).toFixed(0)} m`;
  }
  return `${km.toFixed(2)} km`;
}

/**
 * 格式化速度
 * @param {number} speed km/h
 * @returns {string}
 */
export function formatSpeed(speed) {
  return `${speed.toFixed(1)} km/h`;
}

/**
 * 格式化配速
 * @param {number} speed km/h
 * @returns {string} MM'SS"/km
 */
export function formatPace(speed) {
  if (speed === 0) return "--'--\"";

  const paceMinutes = 60 / speed;
  const minutes = Math.floor(paceMinutes);
  const seconds = Math.floor((paceMinutes - minutes) * 60);

  return `${minutes}'${String(seconds).padStart(2, '0')}"`;
}
```

**文件位置**：`utils/formatter.js`

---

## 状态管理

### Pinia Store

#### theme.js（主题管理）

```javascript
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useThemeStore = defineStore('theme', () => {
  const isDark = ref(false);

  // 从设置中加载主题
  function loadTheme() {
    const settingsRepo = getSettingsRepository();
    const theme = settingsRepo.get('theme', 'auto');

    if (theme === 'dark') {
      isDark.value = true;
    } else if (theme === 'light') {
      isDark.value = false;
    } else {
      // 自动模式：根据系统时间
      const hour = new Date().getHours();
      isDark.value = hour < 6 || hour >= 18;
    }
  }

  function setDark(dark) {
    isDark.value = dark;

    // 保存设置
    const settingsRepo = getSettingsRepository();
    settingsRepo.set('theme', dark ? 'dark' : 'light');
  }

  function toggle() {
    setDark(!isDark.value);
  }

  const themeClass = computed(() => isDark.value ? 'theme-dark' : 'theme-light');

  return {
    isDark,
    themeClass,
    loadTheme,
    setDark,
    toggle
  };
});
```

**使用示例**：

```vue
<script setup>
import { useThemeStore } from '@/store/theme';

const themeStore = useThemeStore();
const themeClass = computed(() => themeStore.themeClass);
</script>

<template>
  <view :class="themeClass">
    <button @click="themeStore.toggle()">切换主题</button>
  </view>
</template>
```

**文件位置**：`store/theme.js`

---

#### units.js（单位管理）

```javascript
import { defineStore } from 'pinia';
import { ref } from 'vue';

export const useUnitsStore = defineStore('units', () => {
  const distanceUnit = ref('km');  // 'km' | 'mi'
  const speedUnit = ref('km/h');   // 'km/h' | 'mph'

  function loadUnits() {
    const settingsRepo = getSettingsRepository();
    distanceUnit.value = settingsRepo.get('distanceUnit', 'km');
    speedUnit.value = settingsRepo.get('speedUnit', 'km/h');
  }

  function setDistanceUnit(unit) {
    distanceUnit.value = unit;
    const settingsRepo = getSettingsRepository();
    settingsRepo.set('distanceUnit', unit);
  }

  function setSpeedUnit(unit) {
    speedUnit.value = unit;
    const settingsRepo = getSettingsRepository();
    settingsRepo.set('speedUnit', unit);
  }

  return {
    distanceUnit,
    speedUnit,
    loadUnits,
    setDistanceUnit,
    setSpeedUnit
  };
});
```

**文件位置**：`store/units.js`

---

### Composables

#### useUnits.js（单位转换）

```javascript
import { computed } from 'vue';
import { useUnitsStore } from '@/store/units';

export function useUnits() {
  const unitsStore = useUnitsStore();

  const distanceUnit = computed(() => unitsStore.distanceUnit);
  const speedUnit = computed(() => unitsStore.speedUnit);

  // 距离转换
  function convertDistance(km) {
    if (distanceUnit.value === 'mi') {
      return km * 0.621371; // km -> mi
    }
    return km;
  }

  // 速度转换
  function convertSpeed(kmh) {
    if (speedUnit.value === 'mph') {
      return kmh * 0.621371; // km/h -> mph
    }
    return kmh;
  }

  return {
    distanceUnit,
    speedUnit,
    convertDistance,
    convertSpeed
  };
}
```

**使用示例**：

```vue
<script setup>
import { useUnits } from '@/composables/useUnits';

const { distanceUnit, speedUnit, convertDistance, convertSpeed } = useUnits();
const distance = ref(10); // 公里
</script>

<template>
  <text>{{ convertDistance(distance).toFixed(2) }} {{ distanceUnit }}</text>
</template>
```

**文件位置**：`composables/useUnits.js`

---

## 性能优化

### 1. 传感器采样优化

```javascript
// 使用 'game' 模式，获得50Hz采样率
uni.startAccelerometer({
  interval: 'game',  // 20ms间隔
  success: () => {
    console.log('加速度计已启动');
  }
});

// 移动平均滤波，窗口大小5
const filter = new MovingAverageFilter(5);
```

### 2. GPS 定位优化

```javascript
// 轨迹点过滤，减少存储
const shouldRecord = shouldRecordPoint(newPoint, lastPoint, {
  minDistance: 5,      // 最小5米
  minInterval: 3000,   // 最小3秒
  maxAccuracy: 50      // 精度50米以内
});
```

### 3. 地图渲染优化

```javascript
// 使用轨迹线而非大量标记点
const polyline = ref([{
  points: trackPoints.value.map(p => ({
    latitude: p.latitude,
    longitude: p.longitude
  })),
  color: '#007AFF',
  width: 4
}]);
```

### 4. 存储优化

```javascript
// 定期清理旧数据
function cleanOldRecords() {
  const repo = getRidingRecordRepository();
  const records = repo.findAll();

  // 保留最近100条
  if (records.length > 100) {
    const toDelete = records
      .sort((a, b) => a.start_time - b.start_time)
      .slice(0, records.length - 100);

    toDelete.forEach(r => repo.deleteById(r.id));
  }
}
```

### 5. 分页加载

```javascript
// 历史记录分页
const page = ref(1);
const pageSize = 10;

async function loadMore() {
  const repo = getRidingRecordRepository();
  const newRecords = repo.findByPage(page.value, pageSize);

  records.value.push(...newRecords);
  page.value++;
}
```

---

## 常见问题

### 1. GPS 定位不准确

**原因**：
- 室内环境
- 冷启动需要时间
- 手机GPS硬件质量

**解决方案**：
```javascript
// 增加精度过滤
const maxAccuracy = 30; // 降低到30米

// 等待GPS稳定
async function waitForStableGPS() {
  let attempts = 0;

  while (attempts < 10) {
    const location = await uni.getLocation({ type: 'gcj02' });

    if (location.accuracy < 30) {
      return location;
    }

    await new Promise(resolve => setTimeout(resolve, 1000));
    attempts++;
  }

  throw new Error('GPS无法稳定');
}
```

### 2. 传感器数据噪声大

**解决方案**：
```javascript
// 增大滤波窗口
const filter = new MovingAverageFilter(10);

// 降低检测灵敏度
sensorService.setSensitivity('low');
```

### 3. 电池消耗快

**解决方案**：
```javascript
// 仅在骑行时启用高频采样
if (isRiding.value) {
  uni.startAccelerometer({ interval: 'game' });
} else {
  uni.stopAccelerometer();
}

// 静止时自动暂停
if (currentSpeed.value < 1) {
  autoPauseTimer = setTimeout(() => {
    if (currentSpeed.value < 1) {
      pauseRiding();
    }
  }, 30000); // 30秒无移动自动暂停
}
```

### 4. 存储空间不足

**解决方案**：
```javascript
// 检查存储空间
const info = wx.getStorageInfoSync();
console.log('已用:', info.currentSize, 'KB');
console.log('限制:', info.limitSize, 'KB');

if (info.currentSize > info.limitSize * 0.8) {
  // 清理旧数据
  cleanOldRecords();
}
```

---

## 总结

本文档详细介绍了 CycloSafe 小程序的完整实现，包括：

- **8个页面**：index, riding, analysis, history, settings, danger-points, emergency-contacts, simulate
- **6个组件**：glass-card, line-chart, m-icon, ride-card, stat-card, tab-bar
- **核心服务**：sensorService（传感器检测）
- **数据层**：Repository模式 + wx.setStorage
- **工具层**：GPS计算、格式化、紧急求助等11个工具
- **状态管理**：Pinia（主题、单位）

**关键特性**：
- 纯客户端架构，无需后端
- 本地数据存储（10MB）
- 多传感器融合检测
- GPS轨迹追踪
- 机器学习数据收集

**下一步**：
- [02-后端实现.md](./02-后端实现.md) - Python后端详解
- [03-数据流和通信.md](./03-数据流和通信.md) - 前后端通信
- [04-部署指南.md](./04-部署指南.md) - 部署说明
- [05-开发指南.md](./05-开发指南.md) - 开发者指南
